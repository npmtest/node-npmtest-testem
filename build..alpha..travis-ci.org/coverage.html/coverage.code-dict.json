{"/home/travis/build/npmtest/node-npmtest-testem/test.js":"/* istanbul instrument in package npmtest_testem */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-testem/lib.npmtest_testem.js":"/* istanbul instrument in package npmtest_testem */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_testem = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_testem = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-testem/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-testem && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_testem */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_testem\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_testem.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_testem.rollup.js'] =\n            local.assetsDict['/assets.npmtest_testem.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_testem.__dirname +\n                    '/lib.npmtest_testem.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/api.js":"'use strict';\n\nvar log = require('npmlog');\nvar Config = require('./config');\nvar EventEmitter = require('events').EventEmitter;\nvar fs = require('fs');\nvar App = require('./app');\nvar Server = require('./server');\n\n/*\n  CLI-level options:\n\n  file:                 [String]  configuration file (testem.json, .testem.json, testem.yml, .testem.yml)\n  host:                 [String]  server host to use (localhost)\n  port:                 [Number]  server port to use (7357)\n  launch:               [Array]   list of launchers to use for current runs (defaults to current mode)\n  skip:                 [Array]   list of launchers to skip\n  debug:                [Boolean] debug mode (false)\n  test_page:            [String|Array]  path (or list of paths) to the page (or pages) to use to run tests\n  growl:                [Boolean] enables growl / native notifications (false)\n\n  Config-level options:\n\n  launchers:            [Object]  List of custom launchers\n  launch_in_dev:        [Array]   list of launchers to use for dev runs\n  launch_in_ci:         [Array]   list of launchers to use for CI runs\n  timeout:              [Number]  timeout for a browser\n  framework:            [String]  test framework to use\n  url:                  [String]  url server runs at (http://{host}:{port}/)\n  src_files:            [Array]   list of files or file patterns to use\n  src_files_ignore:     [Array]   list of files or file patterns to exclude from usage\n  serve_files:          [Array]   list of files or file patterns to inject into test playground (defaults to src_files)\n  watch_files:          [Array]   list of files or file patterns to watch changes of (defaults to src_files)\n  css_files:            [Array]   additional stylesheets to include\n  cwd:                  [Path]    directory to use as root\n  config_dir:           [Path]    directory to use as root for resolving configs, if different than cwd\n  query_params:         [Object]  Object map defining query params to add to the test page. Can be query string also.\n  parallel:             [Number]  max number of parallel runners (1)\n  routes:               [Object]  overrides for assets paths\n  fail_on_zero_tests:   [Boolean] whether process should exit with error status when no tests found\n  unsafe_file_serving:  [Boolean] allow serving directories that are not in your CWD (false)\n\n  Available hooks:\n\n  on_start:             Runs on suite startup\n  before_tests:         Runs before every run of tests\n  after_tests:          Runs after every run of tests\n  on_exit:              Runs before suite exits\n*/\n\nfunction Api() {}\n\nApi.prototype.setup = function(mode, finalizer) {\n  var self = this;\n  this.config = new Config(mode, this.options);\n  this.configureLogging();\n  log.info('Test\\'em starting..');\n  this.config.read(function() {\n    self.app = new App(self.config, finalizer);\n    self.app.start();\n  });\n};\n\nApi.prototype.configureLogging = function() {\n  var debug = this.config.get('debug');\n  if (debug) {\n    log.stream = fs.createWriteStream(debug);\n  } else {\n    var fakeStream = new EventEmitter();\n    fakeStream.write = function() {};\n    log.stream = fakeStream;\n  }\n};\n\nApi.prototype.startDev = function(options, finalizer) {\n  this.options = options;\n  this.setup('dev', finalizer);\n};\n\nApi.prototype.restart = function() {\n  this.app.triggerRun('Api: restart');\n};\n\nApi.prototype.startCI = function(options, finalizer) {\n  this.options = options;\n  this.setup('ci', finalizer);\n};\n\nApi.prototype.startServer = function(options) {\n  this.options = options;\n  var config = this.config = new Config('server', this.options);\n  config.read(function() {\n    var server = new Server(config);\n    server.start();\n    server.on('server-start', function() {\n      console.log('Open ' + config.get('url') + ' in a browser to connect.');\n    });\n  });\n};\n\nmodule.exports = Api;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/config.js":"/*\n\nconfig.js\n=========\n\nThis object returns all config info for the app. It handles reading the `testem.yml`\nor `testem.json` config file.\n\n*/\n'use strict';\n\n\nvar os = require('os');\nvar fs = require('fs');\nvar yaml = require('js-yaml');\nvar log = require('npmlog');\nvar path = require('path');\nvar glob = require('glob');\nvar url = require('url');\nvar querystring = require('querystring');\nvar Bluebird = require('bluebird');\n\nvar browser_launcher = require('./browser_launcher');\nvar LauncherFactory = require('./launcher-factory');\nvar Chars = require('./chars');\nvar pad = require('./strutils').pad;\nvar isa = require('./isa');\nvar fileExists = require('./fileutils').fileExists;\n\nvar knownBrowsers = require('./utils/known-browsers');\nvar globAsync = Bluebird.promisify(glob);\n\nfunction Config(appMode, progOptions, config) {\n  this.appMode = appMode;\n  this.progOptions = progOptions || {};\n  this.fileOptions = {};\n  this.config = config || {};\n  this.getters = {\n    test_page: 'getTestPage'\n  };\n\n  if (appMode === 'dev') {\n    this.progOptions.reporter = 'dev';\n    this.progOptions.parallel = -1;\n  }\n\n  if (this.progOptions.debug === true) {\n    this.progOptions.debug = 'testem.log';\n  }\n\n  if (appMode === 'ci') {\n    this.progOptions.disable_watching = true;\n    this.progOptions.single_run = true;\n  }\n}\n\nConfig.prototype.read = function(callback) {\n  var configFile = this.progOptions.file;\n\n  if (configFile) {\n    this.readConfigFile(configFile, callback);\n  } else {\n    log.info('Seeking for config file...');\n\n    // Try all testem.json, testem.yml and testem.js\n    // testem.json gets precedence\n    var files = ['testem.json', '.testem.json', '.testem.yml', 'testem.yml', 'testem.js', '.testem.js'];\n    return Bluebird.filter(files.map(this.resolveConfigPath.bind(this)), fileExists).then(function(matched) {\n      var configFile = matched[0];\n      if (configFile) {\n        this.readConfigFile(configFile, callback);\n      } else {\n        if (callback) {\n          callback.call(this);\n        }\n      }\n    }.bind(this));\n  }\n};\n\nConfig.prototype.resolvePath = function(filepath) {\n  if (filepath[0] === '/') {\n    return filepath;\n  }\n\n  return path.resolve(this.cwd(), filepath);\n};\n\nConfig.prototype.resolveConfigPath = function(filepath) {\n  if (this.progOptions.config_dir) {\n    return path.resolve(this.progOptions.config_dir, filepath);\n  } else {\n    return this.resolvePath(filepath);\n  }\n};\n\nConfig.prototype.reverseResolvePath = function(filepath) {\n  return path.relative(this.cwd(), filepath);\n};\n\nConfig.prototype.cwd = function() {\n  return this.get('cwd') || process.cwd();\n};\n\nConfig.prototype.readConfigFile = function(configFile, callback) {\n  var self = this;\n  if (!configFile) { // allow empty configFile for programmatic setups\n    if (callback) {\n      callback.call(self);\n    }\n  } else if (configFile.match(/\\.js$/)) {\n    this.readJS(configFile, callback);\n  } else if (configFile.match(/\\.json$/)) {\n    this.readJSON(configFile, callback);\n  } else if (configFile.match(/\\.yml$/)) {\n    this.readYAML(configFile, callback);\n  } else {\n    log.error('Unrecognized config file format for ' + configFile);\n    if (callback) {\n      callback.call(self);\n    }\n  }\n};\n\nConfig.prototype.readJS = function(configFile, callback) {\n  this.fileOptions = require(this.resolveConfigPath(configFile));\n  if (callback) {\n    callback.call(this);\n  }\n};\n\nConfig.prototype.readYAML = function(configFile, callback) {\n  var self = this;\n  fs.readFile(configFile, function(err, data) {\n    if (!err) {\n      var cfg = yaml.load(String(data));\n      self.fileOptions = cfg;\n    }\n    if (callback) {\n      callback.call(self);\n    }\n  });\n};\n\nConfig.prototype.readJSON = function(configFile, callback) {\n  var self = this;\n  fs.readFile(configFile, function(err, data) {\n    if (!err) {\n      var cfg = JSON.parse(data.toString());\n      self.fileOptions = cfg;\n      self.progOptions.file = configFile;\n    }\n    if (callback) {\n      callback.call(self);\n    }\n  });\n};\n\nConfig.prototype.defaults = {\n  host: 'localhost',\n  port: 7357,\n  url: function() {\n    var scheme = 'http';\n    if (this.get('key') || this.get('pfx')) {\n      scheme = 'https';\n    }\n    return scheme + '://' + this.get('host') + ':' + this.get('port') + '/';\n  },\n  parallel: 1,\n  reporter: 'tap',\n  bail_on_uncaught_error: true,\n  browser_start_timeout: 30,\n  browser_disconnect_timeout: 10\n};\n\nConfig.prototype.mergeUrlAndQueryParams = function(urlString, queryParamsObj) {\n  if (!queryParamsObj) {\n    return urlString;\n  }\n\n  if (typeof queryParamsObj === 'string') {\n    if (queryParamsObj[0] === '?') {\n      queryParamsObj = queryParamsObj.substr(1);\n    }\n    queryParamsObj = querystring.parse(queryParamsObj);\n  }\n\n  var urlObj = url.parse(urlString);\n  var outputQueryParams = querystring.parse(urlObj.query) || {};\n  Object.keys(queryParamsObj).forEach(function(param) {\n    outputQueryParams[param] = queryParamsObj[param];\n  });\n  urlObj.query = outputQueryParams;\n  urlObj.search = querystring.stringify(outputQueryParams)\n                    .replace(/\\=&/g, '&')\n                    .replace(/=$/, '');\n  urlObj.path = urlObj.pathname + urlObj.search;\n  return url.format(urlObj);\n};\n\nConfig.prototype.getTestPage = function() {\n  var testPage = this.getConfigProperty('test_page');\n  var queryParams = this.getConfigProperty('query_params');\n  var self = this;\n\n  if (!Array.isArray(testPage)) {\n    testPage = [testPage];\n  }\n\n  return testPage.map(function(page) {\n    return self.mergeUrlAndQueryParams(page, queryParams);\n  });\n};\n\nConfig.prototype.getConfigProperty = function(key) {\n  if (this.config && key in this.config) {\n    return this.config[key];\n  }\n  if (key in this.progOptions && typeof this.progOptions[key] !== 'undefined') {\n    return this.progOptions[key];\n  }\n  if (key in this.fileOptions && typeof this.fileOptions[key] !== 'undefined') {\n    return this.fileOptions[key];\n  }\n  if (key in this.defaults) {\n    var defaultVal = this.defaults[key];\n    if (typeof defaultVal === 'function') {\n      return defaultVal.call(this);\n    } else {\n      return defaultVal;\n    }\n  }\n};\n\nConfig.prototype.get = function(key) {\n  var getterKey = this.getters[key];\n  var getter = getterKey && this[getterKey];\n  if (getter) {\n    return getter.call(this, key);\n  } else {\n    return this.getConfigProperty(key);\n  }\n};\n\nConfig.prototype.set = function(key, value) {\n  if (!this.config) {\n    this.config = {};\n  }\n  this.config[key] = value;\n};\n\nConfig.prototype.isCwdMode = function() {\n  return !this.get('src_files') && !this.get('test_page');\n};\n\nConfig.prototype.getAvailableLaunchers = function(cb) {\n  var self = this;\n\n  var browsers = knownBrowsers(process.platform, self);\n  browser_launcher.getAvailableBrowsers(self, browsers, function(err, availableBrowsers) {\n    if (err) {\n      return cb(err);\n    }\n\n    var availableLaunchers = {};\n    availableBrowsers.forEach(function(browser) {\n      var newLauncher = new LauncherFactory(browser.name, browser, self);\n      availableLaunchers[browser.name.toLowerCase()] = newLauncher;\n    });\n\n    // add custom launchers\n    var customLaunchers = self.get('launchers');\n    if (customLaunchers) {\n      for (var name in customLaunchers) {\n        var newLauncher = new LauncherFactory(name, customLaunchers[name], self);\n        availableLaunchers[name.toLowerCase()] = newLauncher;\n      }\n    }\n    cb(null, availableLaunchers);\n  });\n};\n\nConfig.prototype.getLaunchers = function(cb) {\n  var self = this;\n  this.getAvailableLaunchers(function(err, availableLaunchers) {\n    if (err) {\n      return cb(err);\n    }\n\n    self.getWantedLaunchers(availableLaunchers, cb);\n  });\n};\n\nConfig.prototype.getWantedLauncherNames = function(available) {\n  var launchers = this.get('launch');\n  if (launchers) {\n    launchers = launchers.toLowerCase().split(',');\n  } else if (this.appMode === 'dev') {\n    launchers = this.get('launch_in_dev') || [];\n  } else {\n    launchers = this.get('launch_in_ci') || Object.keys(available);\n  }\n\n  var skip = this.get('skip');\n  if (skip) {\n    skip = skip.toLowerCase().split(',');\n    launchers = launchers.filter(function(name) {\n      return skip.indexOf(name) === -1;\n    });\n  }\n  return launchers;\n};\n\nConfig.prototype.getWantedLaunchers = function(available, cb) {\n  var launchers = [];\n  var wanted = this.getWantedLauncherNames(available);\n  var self = this;\n  var err = null;\n\n  wanted.forEach(function(name) {\n    var launcher = available[name.toLowerCase()];\n    if (!launcher) {\n      if (self.appMode === 'dev' || self.get('ignore_missing_launchers')) {\n        log.warn('Launcher \"' + name + '\" is not recognized.');\n      } else {\n        err = new Error('Launcher ' + name + ' not found. Not installed?');\n      }\n    } else {\n      launchers.push(launcher);\n    }\n  });\n  cb(err, launchers);\n};\n\nConfig.prototype.printLauncherInfo = function() {\n  var self = this;\n  this.getAvailableLaunchers(function(err, launchers) {\n    var launch_in_dev = (self.get('launch_in_dev') || [])\n      .map(function(s) {return s.toLowerCase();});\n    var launch_in_ci = self.get('launch_in_ci');\n    if (launch_in_ci) {\n      launch_in_ci = launch_in_ci.map(function(s) {return s.toLowerCase();});\n    }\n    launchers = Object.keys(launchers).map(function(k) {return launchers[k];});\n    console.log('Have ' + launchers.length + ' launchers available; auto-launch info displayed on the right.');\n    console.log(); // newline\n    console.log('Launcher      Type          CI  Dev');\n    console.log('------------  ------------  --  ---');\n    console.log(launchers.map(function(launcher) {\n      var protocol = launcher.settings.protocol;\n      var kind = protocol === 'browser' ?\n        'browser' : (\n          protocol === 'tap' ?\n            'process(TAP)' : 'process');\n      var dev = launch_in_dev.indexOf(launcher.name.toLowerCase()) !== -1 ?\n        Chars.mark :\n        ' ';\n      var ci = !launch_in_ci || launch_in_ci.indexOf(launcher.name.toLowerCase()) !== -1 ?\n        Chars.mark :\n        ' ';\n      return (pad(launcher.name, 14, ' ', 1) +\n        pad(kind, 12, ' ', 1) +\n        '  ' + ci + '    ' + dev + '      ');\n    }).join('\\n'));\n  });\n};\n\nConfig.prototype.getFileSet = function(want, dontWant, callback) {\n  var self = this;\n  if (isa(want, String)) {\n    want = [want]; // want is an Array\n  }\n  if (isa(dontWant, String)) {\n    dontWant = [dontWant]; // dontWant is an Array\n  }\n\n  // Filter glob < 6 negation patterns to still support them\n  // See https://github.com/isaacs/node-glob/tree/3f883c43#comments-and-negation\n  var positiveWants = [];\n  want.forEach(function(patternEntry) {\n    var pattern = isa(patternEntry, String) ? patternEntry : patternEntry.src;\n    if (pattern.indexOf('!') === 0) {\n      return dontWant.push(pattern.substring(1));\n    }\n\n    positiveWants.push(patternEntry);\n  });\n\n  dontWant = dontWant.map(function(p) {\n    return p ? self.resolvePath(p) : p;\n  });\n  Bluebird.reduce(positiveWants, function(allThatIWant, patternEntry) {\n    var pattern = isa(patternEntry, String) ? patternEntry : patternEntry.src;\n    var attrs = patternEntry.attrs || [];\n    var patternUrl = url.parse(pattern);\n\n    if (patternUrl.protocol === 'file:') {\n      pattern = patternUrl.hostname + patternUrl.path;\n    } else if (patternUrl.protocol) {\n      return allThatIWant.concat({src: pattern, attrs: attrs});\n    }\n\n    return globAsync(self.resolvePath(pattern), { ignore: dontWant }).then(function(files) {\n      return allThatIWant.concat(files.map(function(f) {\n        f = self.reverseResolvePath(f);\n        return {src: f, attrs: attrs};\n      }));\n    });\n  }, []).asCallback(callback);\n};\n\nConfig.prototype.getSrcFiles = function(callback) {\n  var srcFiles = this.get('src_files') || '*.js';\n  var srcFilesIgnore = this.get('src_files_ignore') || '';\n  this.getFileSet(srcFiles, srcFilesIgnore, callback);\n};\n\nConfig.prototype.getServeFiles = function(callback) {\n  var want = this.get('serve_files') || this.get('src_files') || '*.js';\n  var dontWant = this.get('serve_files_ignore') || this.get('src_files_ignore') || '';\n  this.getFileSet(want, dontWant, callback);\n};\n\nConfig.prototype.getUserDataDir = function() {\n  if (this.get('user_data_dir')) {\n    return path.resolve(this.cwd(), this.get('user_data_dir'));\n  }\n\n  return os.tmpdir();\n};\n\nConfig.prototype.getHomeDir = function() {\n  return process.env.HOME || process.env.USERPROFILE;\n};\n\nConfig.prototype.getCSSFiles = function(callback) {\n  var want = this.get('css_files') || '';\n  this.getFileSet(want, '', callback);\n};\n\nConfig.prototype.getAllOptions = function() {\n  var options = [];\n  function getOptions(o) {\n    if (!o) {\n      return;\n    }\n    if (o.options) {\n      o.options.forEach(function(o) {\n        options.push(o.name());\n      });\n    }\n    getOptions(o.parent);\n  }\n  getOptions(this.progOptions);\n  return options;\n};\n\nConfig.prototype.getTemplateData = function(cb) {\n  var ret = {};\n  var options = this.getAllOptions();\n  var key;\n  for (key in this.progOptions) {\n    if (options.indexOf(key) !== -1) {\n      ret[key] = this.progOptions[key];\n    }\n  }\n  for (key in this.fileOptions) {\n    ret[key] = this.fileOptions[key];\n  }\n  for (key in this.config) {\n    ret[key] = this.config[key];\n  }\n  this.getServeFiles(function(err, files) {\n    var replaceSlashes = function(f) {\n      return {src: f.src.replace(/\\\\/g, '/'), attrs: f.attrs};\n    };\n\n    ret.serve_files = files.map(replaceSlashes);\n\n    this.getCSSFiles(function(err, files) {\n      ret.css_files = files.map(replaceSlashes);\n      if (cb) {\n        cb(err, ret);\n      }\n    });\n  }.bind(this));\n};\n\nmodule.exports = Config;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/browser_launcher.js":"/*\n\nbrowser_launcher.js\n===================\n\nThis file more or less figures out how to launch any browser on any platform.\n\n*/\n'use strict';\n\nvar Bluebird = require('bluebird');\n\nvar fileutils = require('./fileutils');\nvar envWithLocalPath = require('./env-with-local-path');\n\nvar executableExists = function(exe) {\n  return fileutils.executableExists(exe, { env: envWithLocalPath() });\n};\nvar fileExists = fileutils.fileExists;\n\n// Returns the available browsers on the current machine.\nfunction getAvailableBrowsers(config, browsers, cb) {\n  browsers.forEach(function(b) {\n    b.protocol = 'browser';\n  });\n\n  return Bluebird.filter(browsers, function(browser) {\n    return isInstalled(browser).then(function(result) {\n      if (!result) {\n        return false;\n      }\n\n      browser.exe = result;\n      return true;\n    });\n  }).asCallback(cb);\n}\n\nfunction isInstalled(browser) {\n  return checkBrowser(browser, 'possiblePath', fileExists).then(function(result) {\n    if (result) {\n      return result;\n    }\n\n    return checkBrowser(browser, 'possibleExe', executableExists);\n  });\n}\n\nfunction checkBrowser(browser, property, method) {\n  if (!browser[property]) {\n    return Bluebird.resolve(false);\n  }\n\n  if (Array.isArray(browser[property])) {\n    return Bluebird.filter(browser[property], method).then(function(result) {\n      if (result.length === 0) {\n        return false;\n      }\n\n      return result[0];\n    });\n  }\n\n  return method(browser[property]).then(function(result) {\n    if (!result) {\n      return false;\n    }\n\n    return browser[property];\n  });\n}\n\nexports.getAvailableBrowsers = getAvailableBrowsers;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/fileutils.js":"'use strict';\n\nvar fs = require('fs');\nvar childProcess = require('child_process');\nvar Bluebird = require('bluebird');\nvar log = require('npmlog');\n\nvar fsStatAsync = Bluebird.promisify(fs.stat);\n\nvar isWin = require('./utils/is-win')();\n\nvar fileExists = function(path) {\n  return fsStatAsync(path).then(function(stats) {\n    return stats.isFile();\n  }).catchReturn(false);\n};\nexports.fileExists = fileExists;\n\nvar executableExists = function(exe, options) {\n  var cmd = isWin ? 'where' : 'which';\n\n  return new Bluebird.Promise(function(resolve) {\n    var test = childProcess.spawn(cmd, [exe], options);\n    test.on('error', function(error) {\n      log.error('Error spawning \"' + cmd + exe + '\"', error);\n    });\n    test.on('close', function(exitCode) {\n      return resolve(exitCode === 0);\n    });\n  });\n};\n\nexports.executableExists = executableExists;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/utils/is-win.js":"'use strict';\n\nfunction test(platform) {\n  return /^win/.test(platform);\n}\n\nvar currentPlatform = test(process.platform);\n\nmodule.exports = function isWin(platform) {\n  if (platform) {\n    return test(platform);\n  }\n\n  return currentPlatform;\n};\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/env-with-local-path.js":"'use strict';\n\nvar path = require('path');\nvar addToPATH = require('./add-to-PATH');\n\nvar modulesPath = path.join(process.cwd(), 'node_modules', '.bin');\n\nmodule.exports = function envWithLocalPath() {\n  return addToPATH(modulesPath);\n};\n\nmodule.exports.PATH = addToPATH.PATH;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/add-to-PATH.js":"'use strict';\n\nvar cloneDeep = require('lodash.clonedeep');\nvar isWin = require('./utils/is-win')();\nvar PATH = 'PATH';\nvar delimiter = ':';\n\n// windows calls it's path 'Path' usually, but this is not guaranteed.\nif (isWin) {\n  PATH = 'Path';\n  delimiter = ';';\n  Object.keys(process.env).forEach(function(e) {\n    if (e.match(/^PATH$/i)) {\n      PATH = e;\n    }\n  });\n}\n\nmodule.exports = function addToPATH(path) {\n  var env = cloneDeep(process.env);\n  env[PATH] = [path, env[PATH]].join(delimiter);\n\n  return env;\n};\n\nmodule.exports.PATH = PATH;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/launcher-factory.js":"'use strict';\n\nvar Launcher = require('./launcher');\nvar extend = require('lodash.assignin');\n\nfunction LauncherFactory(name, settings, config) {\n  this.name = name;\n  this.config = config;\n  this.settings = settings;\n}\n\nLauncherFactory.prototype = {\n  create: function(options) {\n    var settings = extend({}, this.settings, options);\n    return new Launcher(this.name, settings, this.config);\n  }\n};\n\nmodule.exports = LauncherFactory;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/launcher.js":"'use strict';\n\nvar log = require('npmlog');\nvar rimraf = require('rimraf');\nvar mkdirp = require('mkdirp');\nvar path = require('path');\nvar Bluebird = require('bluebird');\n\nvar template = require('./strutils').template;\nvar ProcessCtl = require('./process-ctl');\n\nvar rimrafAsync = Bluebird.promisify(rimraf);\nvar mkdirpAsync = Bluebird.promisify(mkdirp);\n\nfunction Launcher(name, settings, config) {\n  this.name = name;\n  this.config = config;\n  this.settings = settings;\n  this.setupDefaultSettings();\n  this.id = settings.id || String(Math.floor(Math.random() * 10000));\n\n  this.processCtl = new ProcessCtl(name);\n}\n\nLauncher.prototype = {\n  setupDefaultSettings: function() {\n    var settings = this.settings;\n    if (settings.protocol === 'tap' && !('hide_stdout' in settings)) {\n      settings.hide_stdout = true;\n    }\n  },\n  isProcess: function() {\n    return this.settings.protocol !== 'browser';\n  },\n  protocol: function() {\n    return this.settings.protocol || 'process';\n  },\n  commandLine: function() {\n    if (this.settings.command) {\n      return '\"' + this.settings.command + '\"';\n    } else if (this.settings.exe) {\n      return '\"' + this.settings.exe +\n        ' ' + this.getArgs().join(' ') + '\"';\n    }\n  },\n  start: function() {\n    return this.launch();\n  },\n  launch: function() {\n    var self = this;\n    var settings = this.settings;\n    var dir = this.browserTmpDir(this.config, this.id);\n\n    return rimrafAsync(dir).then(function() {\n      return mkdirpAsync(dir);\n    }).then(function() {\n      if (settings.setup) {\n        return Bluebird.fromCallback(function(setupCallback) {\n          settings.setup.call(self, self.config, setupCallback);\n        });\n      }\n\n      return Bluebird.resolve();\n    }).then(function() {\n      return self.doLaunch();\n    });\n  },\n  doLaunch: function() {\n    var settings = this.settings;\n    var self = this;\n    var options = {};\n\n    if (settings.cwd) {\n      options.cwd = settings.cwd;\n    }\n\n    if (settings.exe) {\n      var args = self.getArgs();\n      args = self.template(args);\n\n      return this.processCtl.spawn(settings.exe, args, options);\n    } else if (settings.command) {\n      var cmd = this.template(settings.command);\n      log.info('cmd: ' + cmd);\n\n      return this.processCtl.exec(cmd, options);\n    } else {\n      return Bluebird.reject(new Error('No command or exe/args specified for launcher ' + this.name));\n    }\n  },\n  getId: function() {\n    return this.isProcess() ? -1 : this.id;\n  },\n  getUrl: function() {\n    var baseUrl = this.config.get('url');\n    var testPage = this.settings.test_page;\n    var id = this.getId();\n\n    return baseUrl + id + (testPage ? '/' + testPage : '');\n  },\n  getArgs: function() {\n    var settings = this.settings;\n    var url = this.getUrl();\n    var args = [url];\n    if (settings.args instanceof Array) {\n      args = settings.args.concat(args);\n    } else if (settings.args instanceof Function) {\n      args = settings.args.call(this, this.config, url);\n    }\n    return args;\n  },\n  template: function(thing) {\n    if (Array.isArray(thing)) {\n      return thing.map(this.template, this);\n    } else {\n      var params = {\n        cwd: this.config.cwd(),\n        url: this.getUrl(),\n        baseUrl: this.config.get('url'),\n        port: this.config.get('port'),\n        testPage: this.settings.test_page || '',\n        id: this.getId()\n      };\n      return template(thing, params);\n    }\n  },\n  browserTmpDir: function() {\n    var userDataDir = this.config.getUserDataDir();\n\n    return path.join(userDataDir, 'testem-' + this.id);\n  }\n};\n\nmodule.exports = Launcher;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/strutils.js":"'use strict';\n\n// String padding function adapted from <http://jsfromhell.com/string/pad>\nfunction pad(str, l, s, t) {\n  var ol = l;\n  return (s || (s = ' '), (l -= str.length) > 0 ?\n    (s = new Array(Math.ceil(l / s.length) + 1).join(s))\n    .substr(0, t = !t ? l : t === 1 ? 0 :\n      Math.ceil(l / 2)) + str + s.substr(0, l - t) : str).substring(0, ol);\n}\n\nfunction indent(text, width) {\n  return text.split('\\n').map(function(line) {\n    return new Array((width || 4) + 1).join(' ') + line;\n  }).join('\\n');\n}\n\nfunction splitLines(text, colLimit) {\n  if (!text) {\n    return [];\n  }\n  var firstSplit = text.split('\\n');\n  var secondSplit = [];\n  firstSplit.forEach(function(line) {\n    while (line.length > colLimit) {\n      var first = line.substring(0, colLimit);\n      secondSplit.push(first);\n      line = line.substring(colLimit);\n    }\n    secondSplit.push(line);\n  });\n  return secondSplit;\n}\n\n// Simple template function. Replaces occurences of \"<name>\" with param[name]\nfunction template(str, params) {\n  return !str.replace ? str : str.replace(/<(.+?)>/g, function(unchanged, name) {\n    return name in params ? params[name] : unchanged;\n  });\n}\n\nexports.pad = pad;\nexports.indent = indent;\nexports.splitLines = splitLines;\nexports.template = template;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/process-ctl.js":"'use strict';\n\nvar log = require('npmlog');\nvar crossSpawn = require('cross-spawn');\nvar Bluebird = require('bluebird');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar spawnargs = require('spawn-args');\nvar extend = require('lodash.assignin');\n\nvar envWithLocalPath = require('./env-with-local-path');\nvar fileutils = require('./fileutils');\nvar Process = require('./utils/process');\n\nvar fileExists = fileutils.fileExists;\nvar executableExists = fileutils.executableExists;\n\nfunction ProcessCtl(name, options) {\n  options = options || {};\n\n  this.name = name;\n  this.killTimeout = options.killTimeout || 5000;\n}\n\nProcessCtl.prototype.__proto__ = EventEmitter.prototype;\n\nProcessCtl.prototype.prepareOptions = function(options) {\n  var defaults = {\n    env: envWithLocalPath()\n  };\n\n  return extend({}, defaults, options);\n};\n\nProcessCtl.prototype.spawn = function(exe, args, options) {\n  var _options = this.prepareOptions(options);\n\n  var self = this;\n  var spawn = function spawn(exe) {\n    log.info('spawning: ' + exe + ' - ' + util.inspect(args));\n\n    var p = new Process(this.name, { killTimeout: this.killTimeout }, crossSpawn(exe, args, _options));\n\n    this.emit('processStarted', p);\n\n    return Bluebird.resolve(p);\n  };\n\n  if (Array.isArray(exe)) {\n    return Bluebird.reduce(exe, function(found, exe) {\n      if (found) {\n        return found;\n      }\n\n      return self.exeExists(exe, _options).then(function(exists) {\n        if (exists) {\n          return exe;\n        }\n      });\n    }, false).then(function(found) {\n      if (!found) {\n        return Bluebird.reject(new Error('No executable found in: ' + util.inspect(exe)));\n      }\n\n      return spawn.call(self, found);\n    });\n  }\n\n  return spawn.call(this, exe);\n};\n\nProcessCtl.prototype.exec = function(cmd, options) {\n  log.info('executing: ' + cmd);\n  var cmdParts = spawnargs(cmd);\n  var exe = cmdParts[0];\n  var args = cmdParts.slice(1);\n\n  options = options || {};\n  options.shell = true; // exec uses a shell by default\n\n  return this.spawn(exe, args, options);\n};\n\nProcessCtl.prototype.exeExists = function(exe, options) {\n  return fileExists(exe).then(function(exists) {\n    if (exists) {\n      return exists;\n    }\n\n    return executableExists(exe, options);\n  });\n};\n\nmodule.exports = ProcessCtl;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/utils/process.js":"'use strict';\n\nvar childProcess = require('child_process');\nvar log = require('npmlog');\nvar Bluebird = require('bluebird');\nvar EventEmitter = require('events').EventEmitter;\n\nvar isWin = require('./is-win')();\n\nfunction Process(name, options, process) {\n  var self = this;\n\n  this.name = name;\n  this.killTimeout = options.killTimeout;\n  this.process = process;\n  this.stdout = '';\n  this.stderr = '';\n  this.process.stdout.on('data', function(chunk) {\n    self.stdout += chunk;\n    self.emit('out');\n  });\n  this.process.stderr.on('data', function(chunk) {\n    self.stderr += chunk;\n  });\n\n  this.process.on('close', this.onClose.bind(this));\n  this.process.on('error', this.onError.bind(this));\n}\n\nProcess.prototype.__proto__ = EventEmitter.prototype;\n\nProcess.prototype.onKillTimeout = function() {\n  log.warn('Process ' + this.name + ' not terminated in ' + this.killTimeout + 'ms.');\n  kill(this.process, 'SIGKILL');\n};\n\nProcess.prototype.onClose = function(code) {\n  if (!this.process) {\n    return;\n  }\n  log.warn(this.name + ' closed', code);\n  this.process = null;\n  this.exitCode = code;\n  this.emit('processExit', code, this.stdout, this.stderr);\n};\n\nProcess.prototype.onError = function(error) {\n  log.warn(this.name + ' errored', error);\n  this.process = null;\n  this.exitCode = 1;\n  this.emit('processError', error, this.stdout, this.stderr);\n};\n\nProcess.prototype.onStdOut = function(pattern, fn, timeout) {\n  var self = this;\n  var timeoutID;\n\n  var listener = function() {\n    if (self.patternMatches(pattern)) {\n      if (timeoutID) {\n        clearTimeout(timeoutID);\n      }\n      return fn(null, self.stdout, self.stderr);\n    }\n  };\n\n  this.on('out', listener);\n\n  if (timeout) {\n    timeoutID = setTimeout(function() {\n      self.removeListener('out', listener);\n      return fn(new Error('Timed out without seeing \"' + pattern + '\"'), self.stdout, self.stderr);\n    }, timeout);\n  }\n};\n\nProcess.prototype.patternMatches = function(pattern) {\n  if (typeof pattern === 'string') {\n    return this.stdout.indexOf(pattern) !== -1;\n  } else { // regex\n    return !!this.stdout.match(pattern);\n  }\n};\n\nProcess.prototype.kill = function(sig) {\n  if (!this.process) {\n    log.info('Process ' + this.name + ' already killed.');\n\n    return Bluebird.resolve(this.exitCode);\n  }\n\n  sig = sig || 'SIGTERM';\n\n  var self = this;\n\n  return new Bluebird.Promise(function(resolve) {\n    self.process.once('close', function(code, sig) {\n      self.process = null;\n      if (self._killTimer) {\n        clearTimeout(self._killTimer);\n        self._killTimer = null;\n      }\n      log.info('Process ' + self.name + ' terminated.', code, sig);\n\n      resolve(code);\n    });\n    self.process.on('error', function(err) {\n      log.error('Error killing process ' + self.name + '.', err);\n    });\n    self._killTimer = setTimeout(self.onKillTimeout.bind(self), self.killTimeout);\n    kill(self.process, sig);\n  });\n};\n\n// Kill process and all child processes cross platform\nfunction kill(p, sig) {\n  if (isWin) {\n    var command = 'taskkill.exe';\n    var args = ['/t', '/pid', p.pid];\n    if (sig === 'SIGKILL') {\n      args.push('/f');\n    }\n\n    spawn(command, args).then(function(result) {\n      // Processes without windows can't be killed without /F, detect and force\n      // kill them directly\n      if (result.stderr.indexOf('can only be terminated forcefully') !== -1) {\n        kill(p, 'SIGKILL');\n      }\n    }).catch(function(err) {\n      log.error(err);\n    });\n  } else {\n    p.kill(sig);\n  }\n}\n\nfunction spawn(command, args, options) {\n  return new Bluebird.Promise(function(resolve, reject) {\n    var p = childProcess.spawn(command, args, options);\n    var stdout = '';\n    var stderr = '';\n    p.stdout.on('data', function(chunk) {\n      stdout += chunk;\n    });\n    p.stderr.on('data', function(chunk) {\n      stderr += chunk;\n    });\n    p.on('error', reject);\n    p.on('close', function(code) {\n      resolve({ code: code, stdout: stdout, stderr: stderr });\n    });\n  });\n}\n\nmodule.exports = Process;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/chars.js":"'use strict';\n\nvar isWin = require('./utils/is-win')();\n\n// Special characters to use for drawing.\nvar Chars = {\n  horizontal: '\\u2501',\n  vertical: '\\u2503',\n  topLeft: '\\u250f',\n  topRight: '\\u2513',\n  bottomLeft: '\\u2517',\n  bottomRight: '\\u251b',\n  fail: '\\u2718',\n  success: '\\u2714',\n  cross: '\\u2718',\n  spinner: '\\u25dc\\u25dd\\u25de\\u25df',\n  dot: '\\u00b7',\n  mark: '\\u2714'\n};\n\nif (isWin) {\n  // Windows (by default) doesn't support the cool unicode characters\n  Chars = {\n    horizontal: '-',\n    vertical: '|',\n    topLeft: '+',\n    topRight: '+',\n    bottomLeft: '+',\n    bottomRight: '+',\n    fail: 'x',\n    success: 'v',\n    cross: 'x',\n    spinner: '-\\\\|/',\n    dot: '.',\n    mark: 'x'\n  };\n}\n\nmodule.exports = Chars;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/isa.js":"/*\n\nisa.js\n======\n\nThis is an `isa()` function that does simple and elegant type checking.\nExamples:\n\n  isa([], Array) // true\n  isa(function(){}, Function) // true\n  isa(\"abc\", String) // true\n\n*/\n'use strict';\n\nfunction typeName(ctr) {\n  return ctr.name || String(ctr).match(/function (.{1,})\\(/)[1];\n}\nvar toString = Object.prototype.toString;\nfunction objTypeName(obj) {\n  return toString.call(obj).match(/^\\[object (.*)\\]$/)[1];\n}\n\nfunction isa(obj, type) {\n  if (obj === null || obj === undefined) {\n    return false;\n  }\n  return obj instanceof type || // the straight-forward case\n    obj.constructor === type || // .constructor check to catch the primitives case\n    objTypeName(obj) === typeName(type); // name-based check for the cross window case\n\n}\nmodule.exports = isa;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/utils/known-browsers.js":"'use strict';\n\nvar browserArgs = require('./browser-args');\nvar path = require('path');\nvar fs = require('fs');\nvar isWin = require('./is-win');\n\nfunction chromeWinPaths(homeDir, name) {\n  return [\n    homeDir + '\\\\Local Settings\\\\Application Data\\\\Google\\\\' + name + '\\\\Application\\\\chrome.exe',\n    homeDir + '\\\\AppData\\\\Local\\\\Google\\\\' + name + '\\\\Application\\\\chrome.exe',\n    'C:\\\\Program Files\\\\Google\\\\' + name + '\\\\Application\\\\Chrome.exe',\n    'C:\\\\Program Files (x86)\\\\Google\\\\' + name + '\\\\Application\\\\Chrome.exe'\n  ];\n}\n\nfunction chromeOSXPaths(name) {\n  return [\n    process.env.HOME + '/Applications/' + name + '.app/Contents/MacOS/' + name,\n    '/Applications/' + name + '.app/Contents/MacOS/' + name\n  ];\n}\n\nfunction chromeArgs(browserTmpDir, url) {\n  return [\n    '--user-data-dir=' + browserTmpDir,\n    '--no-default-browser-check',\n    '--no-first-run',\n    '--ignore-certificate-errors',\n    '--test-type',\n    '--disable-renderer-backgrounding',\n    '--disable-background-timer-throttling',\n    url\n  ];\n}\n\n// Return the catalogue of the browsers that Testem supports for the platform. Each 'browser object'\n// will contain these fields:\n//\n// * `name` - the display name of the browser\n// * `exe` - path to the executable to use to launch the browser\n// * `setup(app, done)` - any initial setup needed before launching the executable(this is async,\n//        the second parameter `done()` must be invoked when done).\n// * `supported(cb)` - an async function which tells us whether the browser is supported by the current machine.\nfunction knownBrowsers(platform, config) {\n  var userHomeDir = config.getHomeDir();\n\n  var browsers = [\n    {\n      name: 'Firefox',\n      possiblePath: [\n        'C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe',\n        'C:\\\\Program Files (x86)\\\\Mozilla Firefox\\\\firefox.exe',\n        process.env.HOME + '/Applications/Firefox.app/Contents/MacOS/firefox',\n        '/Applications/Firefox.app/Contents/MacOS/firefox'\n      ],\n      possibleExe: 'firefox',\n\n      args: function(config, url) {\n        return ['-profile', this.browserTmpDir(), url];\n      },\n      setup: function(config, done) {\n        // use user.js instead of prefs.js http://kb.mozillazine.org/User.js_file\n        var perfJS = path.join(this.browserTmpDir(), 'user.js');\n\n        if (config.get('firefox_user_js')) {\n          return fs.readFile(config.get('firefox_user_js'), function(err, content) {\n            if (err) {\n              return done(err);\n            }\n\n            fs.writeFile(perfJS, content, done);\n          });\n        }\n\n        // using user.js to suppress the check default browser popup\n        // and the welcome start page\n        var prefs = [\n          'user_pref(\"browser.shell.checkDefaultBrowser\", false);',\n          'user_pref(\"browser.cache.disk.smart_size.first_run\", false);'\n        ];\n        fs.writeFile(perfJS, prefs.join('\\n'), done);\n      }\n    },\n    {\n      name: 'Chrome',\n      possiblePath: chromeWinPaths(userHomeDir, 'Chrome').concat(chromeOSXPaths('Google\\ Chrome')),\n      possibleExe: [\n        'google-chrome',\n        'google-chrome-stable'\n      ],\n      args: function(config, url) {\n        return chromeArgs(this.browserTmpDir(), url);\n      }\n    },\n    {\n      name: 'Chrome Canary',\n      possiblePath: chromeWinPaths(userHomeDir, 'Chrome SxS').concat(chromeOSXPaths('Google\\ Chrome\\ Canary')),\n      possibleExe: [\n        'google-chrome-canary',\n        'google-chrome-unstable'\n      ],\n      args: function(config, url) {\n        return chromeArgs(this.browserTmpDir(), url);\n      }\n    },\n    {\n      name: 'Chromium',\n      possiblePath: chromeWinPaths(userHomeDir, 'Chromium').concat(chromeOSXPaths('Chromium')),\n      possibleExe: [\n        'chromium-browser',\n        'chromium'\n      ],\n      args: function(config, url) {\n        return chromeArgs(this.browserTmpDir(), url);\n      }\n    },\n    {\n      name: 'Safari',\n      possiblePath: [\n        'C:\\\\Program Files\\\\Safari\\\\safari.exe',\n        'C:\\\\Program Files (x86)\\\\Safari\\\\safari.exe',\n        process.env.HOME + '/Applications/Safari.app/Contents/MacOS/Safari',\n        '/Applications/Safari.app/Contents/MacOS/Safari'\n      ],\n      setup: function(config, done) {\n        var url = this.getUrl();\n        fs.writeFile(\n          path.join(this.browserTmpDir(), 'start.html'),\n          '<script>window.location = \\'' + url + '\\'</script>',\n          done\n        );\n      },\n      args: function() {\n        return [path.join(this.browserTmpDir(), 'start.html')];\n      }\n    },\n    {\n      name: 'Opera',\n      possiblePath: [\n        'C:\\\\Program Files\\\\Opera\\\\opera.exe',\n        'C:\\\\Program Files (x86)\\\\Opera\\\\opera.exe',\n        process.env.HOME + '/Applications/Opera.app/Contents/MacOS/Opera',\n        '/Applications/Opera.app/Contents/MacOS/Opera'\n      ],\n      args: function(config, url) {\n        var operaDataDir = this.browserTmpDir();\n        return ['--user-data-dir=' + operaDataDir, '-pd', operaDataDir, url];\n      }\n    },\n    {\n      name: 'PhantomJS',\n      possibleExe: 'phantomjs',\n      args: function() {\n        var launch_script = config.get('phantomjs_launch_script');\n        if (!launch_script) {\n          launch_script = path.resolve(__dirname, '../../assets/phantom.js');\n        }\n        var options = [launch_script, this.getUrl()];\n        var debug_port = config.get('phantomjs_debug_port');\n        if (debug_port) {\n          options.unshift('--remote-debugger-autorun=true');\n          options.unshift('--remote-debugger-port=' + debug_port);\n        }\n        var phantom_args = config.get('phantomjs_args');\n        if (phantom_args) {\n          options = phantom_args.concat(options);\n        }\n        return options;\n      }\n    }\n  ];\n\n  if (isWin(platform)) {\n    browsers = browsers.concat([\n      {\n        name: 'IE',\n        possiblePath: 'C:\\\\Program Files\\\\Internet Explorer\\\\iexplore.exe'\n      }\n    ]);\n  }\n\n  return browserArgs.addCustomArgs(browsers, config);\n}\n\nmodule.exports = knownBrowsers;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/utils/browser-args.js":"'use strict';\n\nvar capitalize = require('./capitalize');\nvar log = require('npmlog');\n\nfunction Validation() {\n  this.knownBrowser = null;\n  this.messages = [];\n  this.valid = true;\n}\n\nfunction warn(message) {\n  log.warn('', message);\n}\n\nmodule.exports = {\n  addCustomArgs: function(knownBrowsers, config) {\n    if (!knownBrowsers || !config) { return; }\n\n    var browserArgs = config.get('browser_args');\n    var browserName;\n\n    if (browserArgs && typeof browserArgs === 'object') {\n      for (browserName in browserArgs) {\n        if (browserArgs.hasOwnProperty(browserName)) {\n          this.parseArgs(capitalize(browserName), browserArgs[browserName], knownBrowsers);\n        }\n      }\n    } else if (browserArgs !== undefined) {\n      warn('Type error: browser_args should be an object');\n    }\n\n    return knownBrowsers;\n  },\n  createValidation: function() {\n    return new Validation();\n  },\n  dedupeBrowserArgs: function(browserName, browserArgs) {\n    if (!browserName || !(browserArgs instanceof Array)) { return; }\n\n    var argHash = {};\n\n    browserArgs.forEach(function(arg) {\n      if (arg in argHash) {\n        warn('Removed duplicate arg for ' + browserName + ': ' + arg);\n      } else {\n        argHash[arg] = null;\n      }\n    });\n\n    return Object.keys(argHash);\n  },\n  parseArgs: function(browserName, browserArgs, knownBrowsers) {\n    if (!browserName || !browserArgs || !knownBrowsers) { return; }\n\n    var patchArgs;\n    var self = this;\n    var validation = this.validate(browserName, browserArgs, knownBrowsers);\n\n    if (validation.valid) {\n      if (typeof browserArgs === 'string') {\n        browserArgs = [browserArgs];\n      }\n\n      patchArgs = validation.knownBrowser.args;\n\n      if (patchArgs instanceof Array) {\n        validation.knownBrowser.args = browserArgs.concat(validation.knownBrowser.args);\n      } else if (typeof patchArgs === 'function') {\n        validation.knownBrowser.args = function() {\n          return self.dedupeBrowserArgs(browserName,\n            browserArgs.concat(patchArgs.apply(this, arguments)));\n        };\n      } else if (patchArgs === undefined) {\n        validation.knownBrowser.args = function() {\n          return browserArgs;\n        };\n      }\n    } else {\n      validation.messages.forEach(function(message) {\n        warn(message);\n      });\n    }\n  },\n  validate: function(browserName, browserArgs, knownBrowsers) {\n    if (!browserName || !browserArgs || !(knownBrowsers instanceof Array) ||\n      !knownBrowsers.length) { return; }\n\n    var i;\n    var len = knownBrowsers.length;\n    var validation = this.createValidation();\n\n    this.validateBrowserArgs(browserName, browserArgs, validation);\n\n    for (i = 0; i < len; i++) {\n      if (knownBrowsers[i].name === browserName) {\n        validation.knownBrowser = knownBrowsers[i];\n        break;\n      }\n    }\n\n    if (!validation.knownBrowser) {\n      validation.messages.push('Could not find \"' + browserName + '\" in known browsers');\n    }\n\n    validation.valid = !validation.messages.length;\n\n    return validation;\n  },\n  validateBrowserArgs: function(browserName, browserArgs, validation) {\n    if (!browserName || !validation) { return; }\n\n    var arg;\n    var i;\n    var len;\n\n    if (typeof browserArgs !== 'string' && !(browserArgs instanceof Array)) {\n      validation.messages.push('Type error: ' + browserName +\n        '\\'s \"args\" property should be a string or an array');\n    } else if (typeof browserArgs === 'string' && !browserArgs.trim()) {\n      validation.messages.push('Bad value: ' + browserName +\n        '\\'s \"args\" property should not be empty');\n    } else if (browserArgs instanceof Array) {\n      len = browserArgs.length;\n\n      if (len) {\n        for (i = 0; i < len; i++) {\n          arg = browserArgs[i];\n\n          if (typeof arg !== 'string') {\n            validation.messages.push('Bad value: ' + browserName +\n              '\\'s \"args\" may only contain strings');\n            break;\n          } else if (!arg.trim()) {\n            validation.messages.push('Bad value: ' + browserName +\n              '\\'s \"args\" may not contain empty strings');\n            break;\n          }\n        }\n      } else {\n        validation.messages.push('Bad value: ' + browserName + '\\'s \"args\" property should not be empty');\n      }\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/utils/capitalize.js":"'use strict';\n\nmodule.exports = function(str) {\n  if (typeof str !== 'string') { return; }\n\n  // Special case for PhantomJS\n  if (str.toLowerCase() === 'phantomjs') {\n    return 'PhantomJS';\n  }\n\n  return str.replace(/\\w+/g, function(word) {\n    return word.replace(/^[a-z]/, function(firstCharacter) {\n      return firstCharacter.toUpperCase();\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/app.js":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\nvar Bluebird = require('bluebird');\nvar Path = require('path');\nvar log = require('npmlog');\nvar StyledString = require('styled_string');\nvar find = require('lodash.find');\n\nvar Server = require('./server');\nvar BrowserTestRunner = require('./runners/browser_test_runner');\nvar ProcessTestRunner = require('./runners/process_test_runner');\nvar TapProcessTestRunner = require('./runners/tap_process_test_runner');\nvar HookRunner = require('./runners/hook_runner');\nvar cleanExit = require('./clean_exit');\nvar FileWatcher = require('./file_watcher');\nvar Launcher = require('./launcher');\n\nvar RunTimeout = require('./utils/run-timeout');\nvar Reporter = require('./utils/reporter');\nvar SignalListeners = require('./utils/signal-listeners');\n\nfunction App(config, finalizer) {\n  this.exited = false;\n  this.paused = false;\n  this.config = config;\n  this.stdoutStream = config.get('stdout_stream') || process.stdout;\n  this.server = new Server(this.config);\n  this.results = [];\n  this.runnerIndex = 0;\n  this.runners = [];\n  this.timeoutID = undefined;\n\n  this.reportFileName = this.config.get('report_file');\n\n  this.cleanExit = function(err) {\n    var alreadyExit = false;\n    if (!alreadyExit) {\n      alreadyExit = true;\n\n      var exitCode = err ? 1 : 0;\n\n      if (err && err.hideFromReporter) {\n        err = null;\n      }\n\n      (finalizer || cleanExit)(exitCode, err);\n    }\n  };\n}\n\nApp.prototype = {\n  __proto__: EventEmitter.prototype,\n  start: function(cb) {\n    log.info('Starting ' + this.config.appMode);\n    var self = this;\n\n    return Bluebird.using(SignalListeners.with(), function(signalListeners) {\n      signalListeners.on('signal', function(err) {\n        self.exit(err);\n      });\n\n      return Bluebird.using(Reporter.with(self, self.stdoutStream, self.reportFileName), function(reporter) {\n        self.reporter = reporter;\n\n        return Bluebird.using(self.fileWatch(), function() {\n          return Bluebird.using(self.getServer(), function() {\n            return Bluebird.using(self.getRunners(), function() {\n              return Bluebird.using(self.runHook('on_start'), function() {\n                var w = self.waitForTests();\n\n                if (cb) {\n                  cb();\n                }\n\n                return w;\n              }).then(function() {\n                log.info('Stopping ' + self.config.appMode);\n\n                self.emit('tests-finish');\n\n                return Bluebird.using(self.runHook('on_exit'), function() {});\n              });\n            });\n          });\n        });\n      });\n    }).asCallback(this.cleanExit);\n  },\n\n  waitForTests: function() {\n    log.info('Waiting for tests.');\n\n    var self = this;\n    if (this.exited) {\n      return Bluebird.reject(this.exitErr || new Error('Testem exited before running any tests.'));\n    }\n\n    var run = this.triggerRun('Start');\n\n    if (self.config.get('single_run')) {\n      run.then(function() {\n        self.exit();\n      });\n    }\n\n    return new Bluebird.Promise(function(resolve, reject) {\n      self.on('testFinish', resolve);\n      self.on('testError', reject);\n    });\n  },\n\n  triggerRun: function(src) {\n    log.info(src + ' triggered test run.');\n    var self = this;\n\n    if (self.restarting) {\n      return;\n    }\n    self.restarting = true;\n\n    return this.stopCurrentRun().catch(self.exit.bind(this)).then(function() {\n      self.restarting = false;\n\n      return self.runTests();\n    });\n  },\n\n  stopCurrentRun: function() {\n    if (!this.currentRun) {\n      return Bluebird.resolve();\n    }\n\n    return Bluebird.all([ this.stopRunners(), this.currentRun ]);\n  },\n\n  runTests: function() {\n    if (this.paused) {\n      return Bluebird.resolve();\n    }\n\n    log.info('Running tests...');\n\n    var self = this;\n\n    this.reporter.onStart('testem', { launcherId: 0 });\n\n    return Bluebird.using(self.runHook('before_tests'), function() {\n      return Bluebird.using(RunTimeout.with(self.config.get('timeout')), function(timeout) {\n        timeout.on('timeout', function() {\n          self.killRunners();\n        });\n        self.timeoutID = timeout.timeoutID; // TODO Remove, just for the tests\n        self.currentRun = self.singleRun(timeout);\n        self.emit('testRun');\n\n        log.info('Tests running.');\n\n        return self.currentRun;\n      }).then(function() {\n        return Bluebird.using(self.runHook('after_tests'), function() {});\n      });\n    }).catch(function(err) {\n      if (err.hideFromReporter) {\n        return;\n      }\n\n      var result = {\n        failed: 1,\n        passed: 0,\n        name: 'testem',\n        launcherId: 0,\n        error: {\n          message: err.toString()\n        }\n      };\n\n      self.reporter.report('testem', result);\n    }).finally(function() {\n      self.reporter.onEnd('testem', { launcherId: 0 });\n    });\n  },\n\n  exit: function(err, cb) {\n    err = err || this.getExitCode();\n\n    if (this.exited) {\n      if (cb) {\n        cb(err);\n      }\n      return;\n    }\n    this.exited = true;\n    this.exitErr = err;\n\n    if (err) {\n      this.emit('testError', err);\n    } else {\n      this.emit('testFinish');\n    }\n\n    if (cb) {\n      cb(err);\n    }\n    return;\n  },\n\n  startServer: function(callback) {\n    log.info('Starting server');\n    this.server = new Server(this.config);\n    this.server.on('file-requested', this.onFileRequested.bind(this));\n    this.server.on('browser-login', this.onBrowserLogin.bind(this));\n    this.server.on('server-error', this.onServerError.bind(this));\n\n    return this.server.start().asCallback(callback);\n  },\n\n  getServer: function() {\n    var self = this;\n    return this.startServer().disposer(function() {\n      return self.stopServer();\n    });\n  },\n\n  onFileRequested: function(filepath) {\n    if (this.fileWatcher && !this.config.get('serve_files')) {\n      this.fileWatcher.add(filepath);\n    }\n  },\n\n  onServerError: function(err) {\n    this.exit(err);\n  },\n\n  runHook: function(hook, data) {\n    return HookRunner.with(this.config, hook, data);\n  },\n\n  onBrowserLogin: function(browserName, id, socket) {\n    var browser = find(this.runners, function(runner) {\n      return runner.launcherId === id && (!runner.socket || !runner.socket.connected);\n    });\n\n    if (!browser) {\n      var launcher = new Launcher(browserName, {\n        id: id,\n        protocol: 'browser'\n      }, this.config);\n      browser = new BrowserTestRunner(launcher, this.reporter, this.runnerIndex++, this.config);\n      this.addRunner(browser);\n    }\n\n    browser.tryAttach(browserName, id, socket);\n  },\n\n  addRunner: function(runner) {\n    this.runners.push(runner);\n    this.emit('runnerAdded', runner);\n  },\n\n  fileWatch: function() {\n    return this.configureFileWatch().disposer(function() {\n      return;\n    });\n  },\n\n  configureFileWatch: function(cb) {\n    if (this.config.get('disable_watching')) {\n      return Bluebird.resolve().asCallback(cb);\n    }\n\n    this.fileWatcher = new FileWatcher(this.config);\n    this.fileWatcher.on('fileChanged', function(filepath) {\n      log.info(filepath + ' changed (' + (this.disableFileWatch ? 'disabled' : 'enabled') + ').');\n      if (this.disableFileWatch || this.paused) {\n        return;\n      }\n      var configFile = this.config.get('file');\n      if ((configFile && filepath === Path.resolve(configFile)) ||\n        (this.config.isCwdMode() && filepath === process.cwd())) {\n        // config changed\n        this.configure(function() {\n          this.triggerRun('Config changed');\n        }.bind(this));\n      } else {\n        Bluebird.using(this.runHook('on_change', {file: filepath}), function() {\n          this.triggerRun('File changed: ' + filepath);\n        }.bind(this));\n      }\n    }.bind(this));\n    this.fileWatcher.on('EMFILE', function() {\n      var view = this.view;\n      var text = [\n        'The file watcher received a EMFILE system error, which means that ',\n        'it has hit the maximum number of files that can be open at a time. ',\n        'Luckily, you can increase this limit as a workaround. See the directions below \\n \\n',\n        'Linux: http://stackoverflow.com/a/34645/5304\\n',\n        'Mac OS: http://serverfault.com/a/15575/47234'\n      ].join('');\n      view.setErrorPopupMessage(new StyledString(text + '\\n ').foreground('megenta'));\n    }.bind(this));\n\n    return Bluebird.resolve().asCallback(cb);\n  },\n\n  getRunners: function() {\n    var self = this;\n    return Bluebird.fromCallback(function(callback) {\n      self.createRunners(callback);\n    }).disposer(function() {\n      return self.killRunners();\n    });\n  },\n\n  createRunners: function(callback) {\n    var self = this;\n    var reporter = this.reporter;\n    this.config.getLaunchers(function(err, launchers) {\n      if (err) {\n        return callback(err);\n      }\n\n      var testPages = self.config.get('test_page');\n      launchers.forEach(function(launcher) {\n        for (var i = 0; i < testPages.length; i++) {\n          var launcherInstance = launcher.create({ test_page: testPages[i] });\n          var runner = self.createTestRunner(launcherInstance, reporter);\n          self.addRunner(runner);\n        }\n      });\n\n      callback(null);\n    });\n  },\n\n  getRunnerFactory: function(launcher) {\n    var protocol = launcher.protocol();\n    switch (protocol) {\n      case 'process':\n        return ProcessTestRunner;\n      case 'browser':\n        return BrowserTestRunner;\n      case 'tap':\n        return TapProcessTestRunner;\n      default:\n        throw new Error('Don\\'t know about ' + protocol + ' protocol.');\n    }\n  },\n\n  createTestRunner: function(launcher, reporter) {\n    var singleRun = this.config.get('single_run');\n\n    return new (this.getRunnerFactory(launcher))(launcher, reporter, this.runnerIndex++, singleRun, this.config);\n  },\n\n  withTestTimeout: function() {\n    return this.startClock().disposer(function() {\n      return this.cancelExistingTimeout();\n    }.bind(this));\n  },\n\n  singleRun: function(timeout) {\n    var limit = this.config.get('parallel');\n\n    var options = {};\n\n    if (limit && limit >= 1) {\n      options.concurrency = parseInt(limit);\n    } else {\n      options.concurrency = Infinity;\n    }\n\n    return Bluebird.map(this.runners, function(runner) {\n      if (this.exited) {\n        var e = new Error('Run canceled.');\n        e.hideFromReporter = true;\n        return Bluebird.reject(e);\n      }\n      if (this.restarting) {\n        return Bluebird.resolve();\n      }\n      return timeout.try(function() {\n        return runner.start();\n      });\n    }.bind(this), options);\n  },\n\n  wrapUp: function(err) {\n    this.exit(err);\n  },\n\n  stopServer: function(callback) {\n    if (!this.server) {\n      return Bluebird.resolve().asCallback(callback);\n    }\n\n    return this.server.stop().asCallback(callback);\n  },\n\n  getExitCode: function() {\n    if (!this.reporter) {\n      return new Error('Failed to initialize.');\n    }\n    if (!this.reporter.hasPassed()) {\n      var e = new Error('Not all tests passed.');\n      e.hideFromReporter = true;\n      return e;\n    }\n    if (!this.reporter.hasTests() && this.config.get('fail_on_zero_tests')) {\n      return new Error('No tests found.');\n    }\n    return null;\n  },\n\n  stopRunners: function() {\n    return Bluebird.each(this.runners, function(runner) {\n      if (typeof runner.stop === 'function') {\n        return runner.stop();\n      }\n\n      return runner.exit();\n    });\n  },\n\n  killRunners: function() {\n    return Bluebird.each(this.runners, function(runner) {\n      return runner.exit();\n    });\n  },\n\n  launchers: function() {\n    return this.runners.map(function(runner) {\n      return runner.launcher;\n    });\n  }\n};\n\nmodule.exports = App;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/server/index.js":"/*\n\nserver.js\n=========\n\nTestem's server. Serves up the HTML, JS, and CSS required for\nrunning the tests in a browser.\n\n*/\n'use strict';\n\nvar express = require('express');\nvar socketIO = require('socket.io');\nvar fs = require('fs');\nvar path = require('path');\nvar log = require('npmlog');\nvar EventEmitter = require('events').EventEmitter;\nvar Mustache = require('consolidate').mustache;\nvar http = require('http');\nvar https = require('https');\nvar httpProxy = require('http-proxy');\nvar Bluebird = require('bluebird');\n\nvar readFileAsync = Bluebird.promisify(fs.readFile);\n\nfunction Server(config) {\n  this.config = config;\n  this.ieCompatMode = null;\n\n  // Maintain a hash of all connected sockets to close them manually\n  // Workaround https://github.com/joyent/node/issues/9066\n  this.sockets = {};\n  this.nextSocketId = 0;\n}\nServer.prototype = {\n  __proto__: EventEmitter.prototype,\n  start: function(callback) {\n    this.createExpress();\n\n    var self = this;\n\n    // Start the server!\n    // Create socket.io sockets\n    this.server.on('connection', function(socket) {\n      var socketId = self.nextSocketId++;\n      self.sockets[socketId] = socket;\n      socket.on('close', function() {\n        delete self.sockets[socketId];\n      });\n    });\n\n    return new Bluebird.Promise(function(resolve, reject) {\n      self.server.on('listening', function() {\n        self.config.set('port', self.server.address().port);\n        resolve();\n        self.emit('server-start');\n      });\n      self.server.on('error', function(e) {\n        self.stopped = true;\n        reject(e);\n        self.emit('server-error', e);\n      });\n\n      self.server.listen(self.config.get('port'));\n    }).asCallback(callback);\n  },\n  stop: function(callback) {\n    var self = this;\n    if (this.server && !this.stopped) {\n      this.stopped = true;\n\n      return Bluebird.fromCallback(function(closeCallback) {\n        self.server.close(closeCallback);\n\n        // Destroy all open sockets\n        for (var socketId in self.sockets) {\n          self.sockets[socketId].destroy();\n        }\n      }).asCallback(callback);\n    } else {\n      return Bluebird.resolve().asCallback(callback);\n    }\n  },\n  createExpress: function() {\n    var self = this;\n    var app = this.express = express();\n\n    if (this.config.get('key') || this.config.get('pfx')) {\n      var options = {};\n      if (this.config.get('key')) {\n        options.key = fs.readFileSync(this.config.get('key'));\n        options.cert = fs.readFileSync(this.config.get('cert'));\n      } else {\n        options.pfx = fs.readFileSync(this.config.get('pfx'));\n      }\n      this.server = https.createServer(options, this.express);\n    } else {\n      this.server = http.createServer(this.express);\n    }\n    this.io = socketIO(this.server);\n\n    this.io.on('connection', this.onClientConnected.bind(this));\n\n    this.configureExpress(app);\n\n    this.injectMiddleware(app);\n\n    this.configureProxy(app);\n\n    app.get('/', function(req, res) {\n      res.redirect('/' + String(Math.floor(Math.random() * 10000)));\n    });\n\n    app.get(/\\/(-?[0-9]+)$/, function(req, res) {\n      self.serveHomePage(req, res);\n    });\n\n    app.get('/testem.js', function(req, res) {\n      self.serveTestemClientJs(req, res);\n    });\n\n    app.all(/^\\/(?:-?[0-9]+)(\\/.+)$/, serveStaticFile);\n    app.all(/^(.+)$/, serveStaticFile);\n\n    app.use(function(err, req, res, next) {\n      if (err) {\n        log.error(err.message);\n        if (err.code === 'ENOENT') {\n          res.status(404).send('Not found: ' + req.url);\n        } else {\n          res.status(500).send(err.message);\n        }\n      } else {\n        next();\n      }\n    });\n\n    function serveStaticFile(req, res) {\n      self.serveStaticFile(req.params[0], req, res);\n    }\n  },\n  configureExpress: function(app) {\n    var self = this;\n\n    app.engine('mustache', Mustache);\n    app.set('view options', {layout: false});\n    app.use(function(req, res, next) {\n      if (self.ieCompatMode) {\n        res.setHeader('X-UA-Compatible', 'IE=' + self.ieCompatMode);\n      }\n      next();\n    });\n    app.use(express.static(__dirname + '/../../public'));\n  },\n  injectMiddleware: function(app) {\n    var middlewares = this.config.get('middleware');\n    if (middlewares) {\n      middlewares.forEach(function(middleware) {\n        middleware(app);\n      });\n    }\n  },\n  shouldProxy: function(req, opts) {\n    var accepts;\n    var acceptCheck = [\n      'html',\n      'css',\n      'javascript'\n    ];\n\n    //Only apply filtering logic if 'onlyContentTypes' key is present\n    if (!('onlyContentTypes' in opts)) {\n      return true;\n    }\n\n    acceptCheck = acceptCheck.concat(opts.onlyContentTypes);\n    acceptCheck.push('text');\n    accepts = req.accepts(acceptCheck);\n    if (accepts.indexOf(opts.onlyContentTypes) !== -1) {\n      return true;\n    }\n    return false;\n  },\n  configureProxy: function(app) {\n    var proxies = this.config.get('proxies');\n    var self = this;\n    if (proxies) {\n      self.proxy = new httpProxy.createProxyServer({changeOrigin: true});\n\n      self.proxy.on('error', function(err, req, res) {\n        res.status(500).json(err);\n      });\n\n      Object.keys(proxies).forEach(function(url) {\n        app.all(url + '*', function(req, res, next) {\n          var opts = proxies[url];\n          if (self.shouldProxy(req, opts)) {\n            if (opts.host) {\n              opts.target = 'http://' + opts.host + ':' + opts.port;\n              delete opts.host;\n              delete opts.port;\n            }\n            self.proxy.web(req, res, opts);\n          } else {\n            next();\n          }\n        });\n      });\n    }\n  },\n\n  renderRunnerPage: function(err, files, res) {\n    var config = this.config;\n    var framework = config.get('framework') || 'jasmine';\n    var css_files = config.get('css_files');\n    var templateFile = {\n      jasmine: 'jasminerunner',\n      jasmine2: 'jasmine2runner',\n      qunit: 'qunitrunner',\n      mocha: 'mocharunner',\n      'mocha+chai': 'mochachairunner',\n      buster: 'busterrunner',\n      custom: 'customrunner',\n      tap: 'taprunner'\n    }[framework] + '.mustache';\n    res.render(__dirname + '/../../views/' + templateFile, {\n      scripts: files,\n      styles: css_files\n    });\n  },\n  renderDefaultTestPage: function(req, res) {\n    res.header('Cache-Control', 'No-cache');\n    res.header('Pragma', 'No-cache');\n\n    var self = this;\n    var config = this.config;\n    var test_page = config.get('test_page')[0];\n\n    if (test_page) {\n      if (test_page[0] === '/') {\n        test_page = encodeURIComponent(test_page);\n      }\n      var base = req.path === '/' ?\n        req.path : req.path + '/';\n      var url = base + test_page;\n      res.redirect(url);\n    } else {\n      config.getServeFiles(function(err, files) {\n        self.renderRunnerPage(err, files, res);\n      });\n    }\n  },\n  serveHomePage: function(req, res) {\n    var config = this.config;\n    var routes = config.get('routes') || config.get('route') || {};\n    if (routes['/']) {\n      this.serveStaticFile('/', req, res);\n    } else {\n      this.renderDefaultTestPage(req, res);\n    }\n  },\n  serveTestemClientJs: function(req, res) {\n    res.setHeader('Content-Type', 'text/javascript');\n\n    res.write(';(function(){');\n    var files = [\n      'decycle.js',\n      'jasmine_adapter.js',\n      'jasmine2_adapter.js',\n      'qunit_adapter.js',\n      'mocha_adapter.js',\n      'buster_adapter.js',\n      'testem_client.js'\n    ];\n    Bluebird.each(files, function(file) {\n      if (file.indexOf(path.sep) === -1) {\n        file = __dirname + '/../../public/testem/' + file;\n      }\n      return readFileAsync(file).then(function(data) {\n        res.write('\\n//============== ' + path.basename(file) + ' ==================\\n\\n');\n        res.write(data);\n      }).catch(function(err) {\n        res.write('// Error reading ' + file + ': ' + err);\n      });\n    }).then(function() {\n      res.write('}());');\n      res.end();\n    });\n\n  },\n  killTheCache: function killTheCache(req, res) {\n    res.setHeader('Cache-Control', 'No-cache');\n    res.setHeader('Pragma', 'No-cache');\n    delete req.headers['if-modified-since'];\n    delete req.headers['if-none-match'];\n  },\n  route: function route(uri) {\n    var config = this.config;\n    var routes = config.get('routes') || config.get('route') || {};\n    var bestMatchLength = 0;\n    var bestMatch = null;\n    var prefixes = Object.keys(routes);\n    prefixes.forEach(function(prefix) {\n      if (uri.substring(0, prefix.length) === prefix) {\n        if (bestMatchLength < prefix.length) {\n          if (routes[prefix] instanceof Array) {\n            routes[prefix].some(function(folder) {\n              bestMatch = folder + '/' + uri.substring(prefix.length);\n              return fs.existsSync(config.resolvePath(bestMatch));\n            });\n          } else {\n            bestMatch = routes[prefix] + '/' + uri.substring(prefix.length);\n          }\n          bestMatchLength = prefix.length;\n        }\n      }\n    });\n    return {\n      routed: !!bestMatch,\n      uri: bestMatch || uri.substring(1)\n    };\n  },\n  serveStaticFile: function(uri, req, res) {\n    var self = this;\n    var config = this.config;\n    var routeRes = this.route(uri);\n    uri = routeRes.uri;\n    var wasRouted = routeRes.routed;\n    this.killTheCache(req, res);\n    var allowUnsafeDirs = config.get('unsafe_file_serving');\n    var filePath = path.resolve(config.resolvePath(uri));\n    var ext = path.extname(filePath);\n    var isPathPermitted = filePath.indexOf(config.cwd()) !== -1;\n    if (!wasRouted && !allowUnsafeDirs && !isPathPermitted) {\n      res.status(403);\n      res.write('403 Forbidden');\n      res.end();\n    } else if (ext === '.mustache') {\n      config.getTemplateData(function(err, data) {\n        res.render(filePath, data);\n        self.emit('file-requested', filePath);\n      });\n    } else {\n      fs.stat(filePath, function(err, stat) {\n        self.emit('file-requested', filePath);\n        if (err) {\n          return res.sendFile(filePath);\n        }\n        if (stat.isDirectory()) {\n          fs.readdir(filePath, function(err, files) {\n            var dirListingPage = __dirname + '/../../views/directorylisting.mustache';\n            res.render(dirListingPage, {files: files});\n          });\n        } else {\n          res.sendFile(filePath);\n        }\n      });\n    }\n  },\n  onClientConnected: function(client) {\n    var self = this;\n    client.once('browser-login', function(browserName, id) {\n      log.info('New client connected: ' + browserName + ' ' + id);\n      self.emit('browser-login', browserName, id, client);\n    });\n  }\n};\n\nmodule.exports = Server;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/runners/browser_test_runner.js":"'use strict';\n\nvar log = require('npmlog');\nvar BrowserTapConsumer = require('../browser_tap_consumer');\nvar util = require('util');\nvar Bluebird = require('bluebird');\n\nvar toResult = require('./to-result');\n\nfunction BrowserTestRunner(launcher, reporter, index, singleRun, config) {\n  this.launcher = launcher;\n  this.reporter = reporter;\n  this.running = false;\n  this.config = config;\n  this.index = index;\n  this.launcherId = this.launcher.id;\n  this.singleRun = singleRun;\n  this.logs = [];\n\n  this.pendingTimer = undefined;\n  this.onProcessExitTimer = undefined;\n}\n\nBrowserTestRunner.prototype = {\n  start: function(onFinish) {\n    if (this.pending) {\n      return;\n    }\n\n    this.finished = false;\n    this.pending = true;\n\n    return new Bluebird.Promise(function(resolve) {\n      this.onFinish = resolve;\n\n      if (this.socket) {\n        this.socket.emit('start-tests');\n      } else {\n        this.launcher.start().then(function(browserProcess) {\n          this.process = browserProcess;\n          this.process.on('processExit', this.onProcessExit.bind(this));\n          this.process.on('processError', this.onProcessError.bind(this));\n          this.setupStartTimer();\n        }.bind(this)).catch(function(err) {\n          this.onProcessError(err);\n        }.bind(this));\n      }\n    }.bind(this)).asCallback(onFinish);\n  },\n\n  stop: function(cb) {\n    if (this.socket) {\n      this.socket.emit('stop-run');\n    }\n    return Bluebird.resolve().asCallback(cb);\n  },\n\n  exit: function() {\n    if (!this.process) {\n      return Bluebird.resolve();\n    }\n\n    log.info('Closing browser ' + this.name() + '.');\n    return this.process.kill().then(function() {\n      this.process = null;\n    }.bind(this));\n  },\n\n  setupStartTimer: function() {\n    var self = this;\n    this.startTimer = setTimeout(function() {\n      if (self.finished || !self.pending) {\n        return;\n      }\n\n      var err = new Error(\n        'Browser failed to connect within ' + self.launcher.config.get('browser_start_timeout') + 's. ' +\n        'testem.js not loaded?'\n      );\n      self.reportResults(err, 0);\n    }, this.launcher.config.get('browser_start_timeout') * 1000);\n  },\n\n  tryAttach: function(browser, id, socket) {\n    if (id !== this.launcherId) {\n      return;\n    }\n\n    log.info('tryAttach', browser, id);\n\n    if (this.startTimer) {\n      clearTimeout(this.startTimer);\n    }\n    if (this.pendingTimer) {\n      clearTimeout(this.pendingTimer);\n    }\n\n    this.pending = false;\n    this.socket = socket;\n    this.browser = browser;\n    this.logs = [];\n\n    this.onStart.call(this);\n\n    socket.on('test-result', this.onTestResult.bind(this));\n    socket.on('test-metadata', this.onTestMetadata.bind(this));\n    socket.on('top-level-error', this.onGlobalError.bind(this));\n\n    var handleMessage = function(type) {\n      return function(/* ...args */) {\n        var args = Array.prototype.slice.call(arguments);\n        var message = args.map(function(arg) {\n          return util.inspect(arg);\n        }).join(' ');\n\n        this.logs.push({\n          type: type,\n          text: message + '\\n'\n        });\n      }.bind(this);\n    }.bind(this);\n\n    var methods = ['log', 'warn', 'error', 'info'];\n\n    for (var method in methods) {\n      socket.on('console-' + methods[method], handleMessage(methods[method]));\n    }\n\n    socket.on('disconnect', this.onDisconnect.bind(this));\n\n    socket.on('all-test-results', this.onAllTestResults.bind(this));\n    socket.on('after-tests-complete', this.onAfterTests.bind(this));\n\n    var tap = new BrowserTapConsumer(socket);\n    tap.on('test-result', this.onTestResult.bind(this));\n    tap.on('all-test-results', this.onAllTestResults.bind(this));\n    tap.on('all-test-results', function() {\n      this.socket.emit('tap-all-test-results');\n    }.bind(this));\n  },\n\n  name: function() {\n    return this.launcher.name;\n  },\n\n  reportResults: function(err, code, browserProcess) {\n    browserProcess = browserProcess || this.process;\n\n    var result = toResult(this.launcherId, err, code, browserProcess, this.config);\n    this.reporter.report(this.launcher.name, result);\n    this.finish();\n  },\n\n  onTestResult: function(result) {\n    var errItems = (result.items || [])\n      .filter(function(item) {\n        return !item.passed;\n      });\n\n    this.reporter.report(this.browser, {\n      passed: !result.failed && !result.skipped,\n      name: result.name,\n      skipped: result.skipped,\n      runDuration: result.runDuration,\n      logs: this.logs,\n      error: errItems[0],\n      launcherId: this.launcherId,\n      failed: result.failed,\n      pending: result.pending,\n      items: result.items\n    });\n    this.logs = [];\n  },\n\n  onTestMetadata: function(tag, metadata) {\n    this.reporter.reportMetadata(tag, metadata);\n  },\n\n  onStart: function() {\n    this.reporter.onStart(this.browser, {\n      launcherId: this.launcherId\n    });\n  },\n  onEnd: function() {\n    this.reporter.onEnd(this.browser, {\n      launcherId: this.launcherId\n    });\n  },\n  onAllTestResults: function() {\n    log.info('Browser ' + this.name() + ' finished all tests.', this.singleRun);\n    this.onEnd();\n  },\n  onAfterTests: function() {\n    this.finish();\n  },\n  onGlobalError: function(msg, url, line) {\n    var message = msg + ' at ' + url + ', line ' + line + '\\n';\n    this.logs.push({\n      type: 'error',\n      text: message\n    });\n\n    var config = this.launcher.config;\n    if (config.get('bail_on_uncaught_error')) {\n      this.onTestResult.call(this, {\n        failed: 1,\n        name: 'Global error: ' + msg + ' at ' + url + ', line ' + line + '\\n',\n        logs: [],\n        error: {}\n      });\n      this.onAllTestResults();\n      this.onEnd.call(this);\n    }\n  },\n  onDisconnect: function() {\n    this.socket = null;\n    if (this.finished) { return; }\n\n    var self = this;\n\n    this.pending = true;\n    this.pendingTimer = setTimeout(function() {\n      if (self.finished) {\n        return;\n      }\n\n      self.reportResults(new Error('Browser disconnected'), 0);\n    }, this.launcher.config.get('browser_disconnect_timeout') * 1000);\n  },\n  onProcessExit: function(code) {\n    var browserProcess = this.process;\n    this.process = null;\n    if (this.finished) { return; }\n\n    var self = this;\n    this.onProcessExitTimer = setTimeout(function() {\n      if (self.finished) {\n        return;\n      }\n\n      self.reportResults(new Error('Browser exited unexpectedly'), code, browserProcess);\n    }, 1000);\n  },\n  onProcessError: function(err) {\n    var browserProcess = this.process;\n    this.process = null;\n\n    if (this.finished) { return; }\n\n    this.reportResults(err, 0, browserProcess);\n  },\n  finish: function() {\n    if (this.finished) { return; }\n\n    clearTimeout(this.pendingTimer);\n    clearTimeout(this.onProcessExitTimer);\n\n    this.finished = true;\n\n    if (!this.singleRun) {\n      if (this.onFinish) {\n        this.onFinish();\n      }\n      return;\n    }\n    return this.exit().then(function() {\n      // TODO: Not sure how this can happen, but sometimes onFinish is not defined\n      if (this.onFinish) {\n        this.onFinish();\n      }\n    }.bind(this));\n  }\n};\n\nmodule.exports = BrowserTestRunner;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/browser_tap_consumer.js":"'use strict';\n\nvar TapConsumer = require('./tap_consumer');\n\nfunction BrowserTapConsumer(socket, tapConsumer) {\n  tapConsumer = tapConsumer || new TapConsumer();\n  var stream = tapConsumer.stream;\n  socket.on('tap', function(msg) {\n    if (!stream.writable) {\n      return;\n    }\n    stream.write(msg + '\\n');\n    if (msg.match(/^#\\s+ok\\s*$/) ||\n      msg.match(/^#\\s+fail\\s+[0-9]+\\s*$/)) {\n      stream.end();\n    }\n  });\n  return tapConsumer;\n}\n\nmodule.exports = BrowserTapConsumer;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/tap_consumer.js":"'use strict';\n\nvar yaml = require('js-yaml');\nvar extend = require('util')._extend;\nvar EventEmitter = require('events').EventEmitter;\nvar TapParser = require('tap-parser');\nvar log = require('npmlog');\n\nfunction TapConsumer() {\n  this.stream = new TapParser();\n  this.stream.on('assert', this.onTapAssert.bind(this));\n  this.stream.on('extra', this.onTapExtra.bind(this));\n\n  this.stream.on('complete', this.onTapEnd.bind(this));\n  this.stream.on('bailout', this.onTapError.bind(this));\n}\n\nTapConsumer.prototype = {\n  __proto__: EventEmitter.prototype,\n  onTapAssert: function(data) {\n    log.info(data);\n    if (data.skip) {\n      return;\n    }\n\n    if (data.id === undefined) {\n      return;\n    }\n\n    var test = {\n      passed: 0,\n      failed: 0,\n      total: 1,\n      id: data.id,\n      name: data.name ? data.name.trim() : '',\n      items: []\n    };\n\n    if (!data.ok) {\n      var stack;\n      if (data.diag) {\n        stack = data.diag.stack || data.diag.at;\n      }\n      if (stack) {\n        stack = yaml.dump(stack);\n      }\n      data = extend(data, data.diag);\n\n      this.latestItem = extend(data, {\n        passed: false,\n        stack: stack\n      });\n      test.items.push(this.latestItem);\n      test.failed++;\n    } else {\n      test.passed++;\n    }\n    this.emit('test-result', test);\n  },\n  onTapExtra: function(extra) {\n    if (!this.latestItem) {\n      return;\n    }\n\n    if (this.latestItem.stack) {\n      this.latestItem.stack += extra;\n    } else {\n      this.latestItem.stack = extra;\n    }\n  },\n  onTapError: function(reason) {\n    var test = {\n      failed: 1,\n      name: 'bailout',\n      items: [],\n      error: {\n        message: reason\n      }\n    };\n\n    this.stream.removeAllListeners();\n    this.emit('test-result', test);\n    this.emit('all-test-results');\n  },\n  onTapEnd: function() {\n    this.stream.removeAllListeners();\n    this.emit('all-test-results');\n  }\n};\n\nmodule.exports = TapConsumer;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/runners/to-result.js":"'use strict';\n\nvar log = require('npmlog');\n\nmodule.exports = function toResult(launcherId, err, code, runnerProcess, config) {\n  var logs = [];\n  var message = '';\n\n  if (err) {\n    logs.push({\n      type: 'error',\n      text: err.toString()\n    });\n\n    message += err + '\\n';\n  }\n\n  if (code !== 0) {\n    logs.push({\n      type: 'error',\n      text: 'Non-zero exit code: ' + code\n    });\n\n    message += 'Non-zero exit code: ' + code + '\\n';\n  }\n\n  if (runnerProcess && runnerProcess.stderr) {\n    logs.push({\n      type: 'error',\n      text: runnerProcess.stderr\n    });\n\n    message += 'Stderr: \\n ' + runnerProcess.stderr + '\\n';\n  }\n\n  if (runnerProcess && runnerProcess.stdout) {\n    logs.push({\n      type: 'log',\n      text: runnerProcess.stdout\n    });\n\n    message += 'Stdout: \\n ' + runnerProcess.stdout + '\\n';\n  }\n\n  if (config && config.get('debug')) {\n    log.info(runnerProcess.name + '.stdout', runnerProcess.stdout);\n    log.info(runnerProcess.name + '.stderr', runnerProcess.stderr);\n  }\n\n  var result = {\n    failed: code === 0 && !err ? 0 : 1,\n    passed: code === 0 && !err ? 1 : 0,\n    name: 'error',\n    launcherId: launcherId,\n    logs: logs\n  };\n  if (!result.passed) {\n    result.error = {\n      message: message\n    };\n  }\n\n  return result;\n};\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/runners/process_test_runner.js":"'use strict';\nvar Bluebird = require('bluebird');\n\nvar toResult = require('./to-result');\n\nfunction ProcessTestRunner(launcher, reporter) {\n  this.launcher = launcher;\n  this.reporter = reporter;\n  this.launcherId = this.launcher.id;\n  this.finished = false;\n}\nProcessTestRunner.prototype = {\n  start: function(onFinish) {\n    this.onStart();\n    this.finished = false;\n\n    return new Bluebird.Promise(function(resolve, reject) {\n      this.onFinish = resolve;\n      this.launcher.start().then(function(testProcess) {\n        this.process = testProcess;\n        this.process.once('processExit', this.onProcessExit.bind(this));\n        this.process.once('processError', this.onProcessError.bind(this));\n      }.bind(this)).catch(reject);\n    }.bind(this)).asCallback(onFinish);\n  },\n\n  exit: function() {\n    if (!this.process) {\n      return Bluebird.resolve();\n    }\n\n    return this.process.kill();\n  },\n\n  onProcessExit: function(code, stdout, stderr) {\n    this.finish(null, code, stdout, stderr);\n  },\n\n  name: function() {\n    return this.launcher.name;\n  },\n\n  onProcessError: function(err, stdout, stderr) {\n    this.lastErr = err;\n    this.lastStderr = stderr;\n    this.finish(err, 0, stdout, stderr);\n  },\n\n  onStart: function() {\n    this.reporter.onStart(this.launcher.name, {\n      launcherId: this.launcherId\n    });\n  },\n\n  onEnd: function() {\n    this.reporter.onEnd(this.launcher.name, {\n      launcherId: this.launcherId\n    });\n  },\n\n  finish: function(err, code) {\n    if (this.finished) {\n      return;\n    }\n    this.finished = true;\n    var runnerProcess = this.process;\n    this.process = null;\n\n    var result = toResult(this.launcherId, err, code, runnerProcess);\n    this.reporter.report(this.launcher.name, result);\n    this.onEnd();\n\n    this.onFinish();\n  }\n};\n\nmodule.exports = ProcessTestRunner;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/runners/tap_process_test_runner.js":"'use strict';\n\nvar TapConsumer = require('../tap_consumer');\nvar log = require('npmlog');\nvar Bluebird = require('bluebird');\n\nvar toResult = require('./to-result');\n\nfunction TapProcessTestRunner(launcher, reporter) {\n  this.launcher = launcher;\n  this.reporter = reporter;\n  this.launcherId = this.launcher.id;\n  this.finished = false;\n  log.info(this.launcher.name);\n}\nTapProcessTestRunner.prototype = {\n  start: function(onFinish) {\n    this.onStart();\n    this.finished = false;\n\n    this.tapConsumer = new TapConsumer();\n    this.tapConsumer.on('test-result', this.onTestResult.bind(this));\n    this.tapConsumer.on('all-test-results', this.onAllTestResults.bind(this));\n\n    return new Bluebird.Promise(function(resolve, reject) {\n      this.onFinish = resolve;\n      this.launcher.start().then(function(tapProcess) {\n        this.process = tapProcess;\n        this.process.once('processError', this.onProcessError.bind(this));\n        this.process.process.stdout.pipe(this.tapConsumer.stream);\n      }.bind(this)).catch(reject);\n    }.bind(this)).asCallback(onFinish);\n  },\n  exit: function() {\n    if (!this.process) {\n      return Bluebird.resolve();\n    }\n\n    return this.process.kill();\n  },\n  onTestResult: function(test) {\n    test.launcherId = this.launcherId;\n    this.reporter.report(this.launcher.name, test);\n  },\n  onAllTestResults: function() {\n    setTimeout(function() { // Workaround Node 0.10 finishing stdout before receiving process error\n      this.wrapUp();\n    }.bind(this), 100);\n  },\n  wrapUp: function() {\n    if (this.finished) {\n      return;\n    }\n    this.finished = true;\n    this.process = null;\n    this.onEnd();\n    this.onFinish();\n  },\n  name: function() {\n    return this.launcher.name;\n  },\n  onProcessError: function(err) {\n    var result = toResult(this.launcherId, err, 0, this.process);\n    this.reporter.report(this.launcher.name, result);\n    this.wrapUp();\n  },\n  onStart: function() {\n    this.reporter.onStart(this.launcher.name, {\n      launcherId: this.launcherId\n    });\n  },\n\n  onEnd: function() {\n    this.reporter.onEnd(this.launcher.name, {\n      launcherId: this.launcherId\n    });\n  }\n};\n\nmodule.exports = TapProcessTestRunner;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/runners/hook_runner.js":"'use strict';\n\nvar Bluebird = require('bluebird');\nvar log = require('npmlog');\n\nvar template = require('../strutils').template;\nvar ProcessCtl = require('../process-ctl');\n\nfunction HookRunner(config) {\n  this.config = config;\n}\n\nHookRunner.with = function(config, hook, data) {\n  var hookRunner = new HookRunner(config);\n\n  return hookRunner.run(hook, data).catch(function(err) {\n    log.error(hook + ' error', err);\n\n    throw err;\n  }).disposer(function() {\n    return hookRunner.stop();\n  });\n};\n\nHookRunner.prototype = {\n  run: function(hook, data, callback) {\n    var hookCfg = this.config.get(hook);\n    if (!hookCfg) {\n      return Bluebird.resolve();\n    }\n    if (typeof hookCfg === 'function') {\n      return Bluebird.fromCallback(function(callback) {\n        hookCfg(this.config, data, callback);\n      }.bind(this));\n    }\n\n    this.processCtl = new ProcessCtl(hook);\n\n    var command;\n    var exe;\n    var args;\n    var waitForText;\n    var waitForTextTimeout;\n    var badText;\n    var badTextTimeout;\n\n    if (typeof hookCfg === 'object') {\n      command = hookCfg.command;\n      exe = hookCfg.exe;\n      args = hookCfg.args;\n      waitForText = hookCfg.wait_for_text;\n      waitForTextTimeout = hookCfg.wait_for_text_timeout;\n      badText = hookCfg.bad_text;\n      badTextTimeout = hookCfg.bad_text_timeout;\n    } else if (typeof hookCfg === 'string') {\n      command = hookCfg;\n    }\n\n    var options = {\n      cwd: this.config.cwd()\n    };\n\n    var hookProcessPromise;\n    if (command) {\n      command = this.varsub(command, data);\n      hookProcessPromise = this.processCtl.exec(command, options);\n    } else if (exe) {\n      args = this.varsub(args || []);\n      hookProcessPromise = this.processCtl.spawn(exe, args, options);\n      command = exe + ' ' + args.join(' ');\n    } else {\n      return Bluebird.reject(new Error('No command or exe/args specified for hook ' + hook));\n    }\n\n    waitForTextTimeout = waitForTextTimeout || 10000;\n    badTextTimeout = badTextTimeout || waitForTextTimeout;\n\n    var exited = false;\n    var finished;\n    var p = new Bluebird.Promise(function(resolve, reject) {\n      finished = function(err, stdout, stderr) {\n        if (exited) {\n          return;\n        }\n        exited = true;\n\n        if (err) {\n          return reject(err);\n        }\n\n        return resolve({ stdout: stdout, stderr: stderr });\n      };\n    });\n\n    hookProcessPromise.then(function(hookProcess) {\n      this.hookProcess = hookProcess;\n\n      hookProcess.on('processExit', function(code, stdout, stderr) {\n        if (code !== 0) {\n          return finished(createError('Non-zero exit code: ' + code, hook, stdout, stderr));\n        }\n\n        finished(null, stdout, stderr);\n      });\n\n      hookProcess.on('processError', function(err, stdout, stderr) {\n        finished(err, stdout, stderr);\n      });\n\n      if (waitForText) {\n        hookProcess.onStdOut(this.varsub(waitForText), finished, waitForTextTimeout);\n      }\n      if (badText) {\n        hookProcess.onStdOut(this.varsub(badText), function(err, stdout, stderr) {\n          if (err) {\n            return finished(null, stdout, stderr);\n          }\n\n          finished(createError('Found bad match (' + badText + ')', hook, stdout, stderr));\n        }, badTextTimeout);\n      }\n    }.bind(this));\n\n    return p.asCallback(callback);\n  },\n  varsubParams: function() {\n    return {\n      host: this.config.get('host'),\n      port: this.config.get('port'),\n      url: this.config.get('url')\n    };\n  },\n  varsub: function(thing, data) {\n    if (Array.isArray(thing)) {\n      return thing.map(function(str) {\n        return this.varsub(str, data);\n      }, this);\n    } else {\n      thing = template(thing, this.varsubParams());\n      thing = data ? template(thing, data) : thing;\n      return thing;\n    }\n  },\n  stop: function() {\n    if (this.hookProcess) {\n      return this.hookProcess.kill();\n    }\n\n    return Bluebird.resolve();\n  }\n};\n\nfunction createError(message, hook, stdout, stderr) {\n  return new Error(message + '\\nHook: ' + hook + '\\nStdout:\\n' + stdout + '\\nStderr:\\n' + stderr);\n}\n\nmodule.exports = HookRunner;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/clean_exit.js":"'use strict';\n\nfunction cleanExit(code) {\n  // Workaround for this node core bug <https://github.com/joyent/node/issues/3584>\n  // Instead of using `process.exit(?code)`, use this instead.\n  //\n  var draining = 0;\n  var exit = function() {\n    if (!(draining--)) {\n      process.exit(code);\n    }\n  };\n  var streams = [process.stdout, process.stderr];\n  streams.forEach(function(stream) {\n    // submit empty write request and wait for completion\n    draining += 1;\n    stream.write('', exit);\n  });\n  exit();\n}\n\nmodule.exports = cleanExit;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/file_watcher.js":"'use strict';\n\nvar fireworm = require('fireworm');\nvar EventEmitter = require('events').EventEmitter;\n\nvar FileWatcher = function(config) {\n  this.fileWatcher = fireworm('./', {\n    ignoreInitial: true,\n    skipDirEntryPatterns: []\n  });\n  var onFileChanged = this.onFileChanged.bind(this);\n  this.fileWatcher.on('change', onFileChanged);\n  this.fileWatcher.on('add', onFileChanged);\n  this.fileWatcher.on('remove', onFileChanged);\n  this.fileWatcher.on('emfile', this.onEMFILE.bind(this));\n\n  var watchFiles = config.get('watch_files');\n  this.fileWatcher.clear();\n  var confFile = config.get('file');\n  if (confFile) {\n    this.fileWatcher.add(confFile);\n  }\n  if (config.isCwdMode()) {\n    this.fileWatcher.add('*.js');\n  }\n  if (watchFiles) {\n    this.fileWatcher.add(watchFiles);\n  }\n  var srcFiles = config.get('src_files') || '*.js';\n  this.fileWatcher.add(srcFiles);\n  var ignoreFiles = config.get('src_files_ignore');\n  if (ignoreFiles) {\n    this.fileWatcher.ignore(ignoreFiles);\n  }\n};\n\nFileWatcher.prototype = {\n  __proto__: EventEmitter.prototype\n};\n\nFileWatcher.prototype.onFileChanged = function(filePath) {\n  this.emit('fileChanged', filePath);\n};\n\nFileWatcher.prototype.onEMFILE = function() {\n  this.emit('EMFILE');\n};\n\nFileWatcher.prototype.add = function(file) {\n  this.fileWatcher.add(file);\n};\n\nmodule.exports = FileWatcher;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/utils/run-timeout.js":"'use strict';\n\nvar Bluebird = require('bluebird');\nvar EventEmitter = require('events').EventEmitter;\n\nfunction RunTimeout(timeout) {\n  this.timeout = timeout;\n}\n\nRunTimeout.with = function(timeout) {\n  var runTimeout = new RunTimeout(timeout);\n\n  return runTimeout.start().disposer(function() {\n    return runTimeout.stop();\n  }.bind(this));\n};\n\nRunTimeout.prototype.__proto__ = EventEmitter.prototype;\n\nRunTimeout.prototype.start = function() {\n  var self = this;\n\n  if (this.timeout) {\n    this.timeoutID = setTimeout(function() {\n      self.setTimedOut();\n    }, this.timeout * 1000);\n  }\n\n  return Bluebird.resolve(this);\n};\n\nRunTimeout.prototype.setTimedOut = function() {\n  this.timedOut = true;\n  this.emit('timeout');\n};\n\nRunTimeout.prototype.stop = function() {\n  clearTimeout(this.timeoutID);\n  this.timeoutID = null;\n  this.timedOut = null;\n};\n\nRunTimeout.prototype.try = function(fn) {\n  if (this.timedOut) {\n    return Bluebird.reject(new Error('Run timed out.'));\n  }\n\n  return fn();\n};\n\nmodule.exports = RunTimeout;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/utils/reporter.js":"'use strict';\n\nvar Bluebird = require('bluebird');\n\nvar reporters = require('../reporters');\nvar isa = require('../isa');\nvar ReportFile = require('./report-file');\n\nfunction setupReporter(name, out, config, app) {\n  var reporter;\n\n  if (isa(name, String)) {\n    var TestReporter = reporters[name];\n    if (TestReporter) {\n      reporter = new TestReporter(false, out, config, app);\n    }\n  } else {\n    reporter = name;\n  }\n\n  if (!reporter) {\n    throw new Error('Test reporter `' + name + '` not found.');\n  }\n\n  return reporter;\n}\n\n\nfunction Reporter(app, stdout, path) {\n  this.total = 0;\n  this.passed = 0;\n  this.skipped = 0;\n\n  if (path) {\n    this.reportFile = new ReportFile(path);\n  }\n\n  var config = app.config;\n\n  if (path && config.get('xunit_intermediate_output') && config.get('reporter') === 'xunit') {\n    this.reporters = [\n      setupReporter('tap', stdout, config, app),\n      setupReporter(config.get('reporter'), this.reportFile.outputStream, config, app)\n    ];\n  } else {\n    this.reporters = [setupReporter(config.get('reporter'), stdout, config, app)];\n\n    if (path) {\n      this.reporters.push(setupReporter(config.get('reporter'), this.reportFile.outputStream, config, app));\n    }\n  }\n}\n\nReporter.with = function(app, stdout, path) {\n  return Bluebird.try(function() {\n    return new Reporter(app, stdout, path);\n  }).disposer(function(reporter, promise) {\n    if (promise.isRejected()) {\n      var err = promise.reason();\n\n      if (!err.hideFromReporter) {\n        reporter.report(null, {\n          passed: false,\n          name: err.name || 'unknown error',\n          error: {\n            message: err.message\n          }\n        });\n      }\n    }\n\n    return reporter.close();\n  });\n};\n\nReporter.prototype.close = function() {\n  this.finish();\n\n  if (this.reportFile) {\n    return this.reportFile.close();\n  }\n};\n\nReporter.prototype.hasTests = function() {\n  return this.total > 0;\n};\n\nReporter.prototype.hasPassed = function() {\n  return this.total <= ((this.passed || 0) + (this.skipped || 0));\n};\n\nfunction forwardToReporters(fn) {\n  return function() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; ++i) {\n      args[i] = arguments[i];\n    }\n\n    this.reporters.forEach(function(reporter) {\n      if (reporter[fn]) {\n        reporter[fn].apply(reporter, args);\n      }\n    });\n  };\n}\n\nReporter.prototype.report = function(name, result) {\n  this.total++;\n  if (result.skipped) {\n    this.skipped++;\n  } else if (result.passed) {\n    this.passed++;\n  }\n\n  this.reporters.forEach(function(reporter) {\n    reporter.report(name, result);\n  });\n};\n\n['finish', 'onStart', 'onEnd', 'reportMetadata'].forEach(function(fn) {\n  Reporter.prototype[fn] = forwardToReporters(fn);\n});\n\nmodule.exports = Reporter;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/reporters/index.js":"'use strict';\n\nmodule.exports = {\n  tap: require('./tap_reporter'),\n  xunit: require('./xunit_reporter'),\n  dot: require('./dot_reporter'),\n  teamcity: require('./teamcity_reporter'),\n  dev: require('./dev')\n};\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/reporters/tap_reporter.js":"'use strict';\n\nvar displayutils = require('../displayutils');\n\nfunction TapReporter(silent, out) {\n  this.out = out || process.stdout;\n  this.silent = silent;\n  this.stoppedOnError = null;\n  this.id = 1;\n  this.total = 0;\n  this.pass = 0;\n  this.skipped = 0;\n  this.results = [];\n  this.errors = [];\n  this.logs = [];\n}\nTapReporter.prototype = {\n  report: function(prefix, data) {\n    this.results.push({\n      launcher: prefix,\n      result: data\n    });\n    this.display(prefix, data);\n    this.total++;\n    if (data.skipped) {\n      this.skipped++;\n    } else if (data.passed) {\n      this.pass++;\n    }\n  },\n  summaryDisplay: function() {\n    var lines = [\n      '1..' + this.total,\n      '# tests ' + this.total,\n      '# pass  ' + this.pass,\n      '# skip  ' + this.skipped,\n      '# fail  ' + (this.total - this.pass - this.skipped)\n    ];\n\n    if (this.pass + this.skipped === this.total) {\n      lines.push('');\n      lines.push('# ok');\n    }\n    return lines.join('\\n');\n  },\n  display: function(prefix, result) {\n    if (this.silent) {\n      return;\n    }\n    this.out.write(displayutils.resultString(this.id++, prefix, result));\n  },\n  finish: function() {\n    if (this.silent) {\n      return;\n    }\n    this.out.write('\\n' + this.summaryDisplay() + '\\n');\n  }\n};\n\nmodule.exports = TapReporter;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/displayutils.js":"'use strict';\n\nvar util = require('util');\n\n// Method to format test results.\nvar strutils = require('./strutils');\n\nfunction resultDisplay(id, prefix, result) {\n\n  var parts = [];\n  if (prefix) {\n    parts.push(prefix);\n  }\n  if (result.name) {\n    parts.push(result.name.trim());\n  }\n\n  var line = parts.join(' - ');\n  return (result.skipped ? 'skip ' : (result.passed ? 'ok ' : 'not ok ')) + id + ' ' + line;\n}\n\nfunction yamlDisplay(err, logs) {\n  var testLogs;\n  var failed = Object.keys(err || {})\n    .filter(function(key) {\n      return key !== 'passed';\n    })\n    .map(function(key) {\n      return key + ': >\\n' + strutils.indent(String(err[key]));\n    });\n  if (logs) {\n    testLogs = ['Log: |'].concat(logs.map(function(log) {return strutils.indent(util.inspect(log));}));\n  } else {\n    testLogs = [];\n  }\n  return strutils.indent([\n    '---',\n    strutils.indent(failed.concat(testLogs).join('\\n')),\n    '...'].join('\\n'));\n}\n\nfunction resultString(id, prefix, result) {\n  var string = resultDisplay(id, prefix, result) + '\\n';\n  if (result.error || result.logs && result.logs.length) {\n    string += yamlDisplay(result.error, result.logs) + '\\n';\n  }\n  return string;\n}\n\nexports.resultString = resultString;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/reporters/xunit_reporter.js":"'use strict';\n\nvar XmlDom = require('xmldom');\n\nfunction XUnitReporter(silent, out, config) {\n  this.out = out || process.stdout;\n  this.excludeStackTraces = config.get('xunit_exclude_stack');\n  this.silent = silent;\n  this.stoppedOnError = null;\n  this.id = 1;\n  this.total = 0;\n  this.pass = 0;\n  this.skipped = 0;\n  this.results = [];\n  this.startTime = new Date();\n  this.endTime = null;\n}\nXUnitReporter.prototype = {\n  report: function(prefix, data) {\n    this.results.push({\n      launcher: prefix,\n      result: data\n    });\n    this.display(prefix, data);\n    this.total++;\n    if (data.skipped) {\n      this.skipped++;\n    } else if (data.passed) {\n      this.pass++;\n    }\n  },\n  finish: function() {\n    if (this.silent) {\n      return;\n    }\n    this.endTime = new Date();\n    this.out.write(this.summaryDisplay());\n    this.out.write('\\n');\n  },\n  summaryDisplay: function() {\n    var doc = new XmlDom.DOMImplementation().createDocument('', 'testsuite');\n\n    var rootNode = doc.documentElement;\n    rootNode.setAttribute('name', 'Testem Tests');\n    rootNode.setAttribute('tests', this.total);\n    rootNode.setAttribute('skipped', this.skipped);\n    rootNode.setAttribute('failures', this.failures());\n    rootNode.setAttribute('timestamp', new Date());\n    rootNode.setAttribute('time', this.duration());\n\n    for (var i = 0, len = this.results.length; i < len; i++) {\n      var testcaseNode = this.getTestResultNode(doc, this.results[i]);\n      rootNode.appendChild(testcaseNode);\n    }\n    return doc.documentElement.toString();\n  },\n  display: function() {\n    // As the output is XML, the XUnitReporter can only write its results after all\n    // tests have finished.\n    return;\n  },\n  getTestResultNode: function(document, result) {\n    var launcher = result.launcher;\n    result = result.result;\n\n    var resultNode = document.createElement('testcase');\n    resultNode.setAttribute('classname', launcher);\n    resultNode.setAttribute('name', result.name);\n    resultNode.setAttribute('time', this._durationFromMs(result.runDuration));\n\n    var error = result.error;\n    if (error) {\n      var errorNode = document.createElement('error');\n      errorNode.setAttribute('message', error.message);\n      if (error.stack && !this.excludeStackTraces) {\n        var cdata = document.createCDATASection(error.stack);\n        errorNode.appendChild(cdata);\n      }\n      resultNode.appendChild(errorNode);\n    } else if (result.skipped) {\n      var skippedNode = document.createElement('skipped');\n      resultNode.appendChild(skippedNode);\n    } else if (!result.passed) {\n      var failureNode = document.createElement('failure');\n      resultNode.appendChild(failureNode);\n    }\n\n    return resultNode;\n  },\n  failures: function() {\n    return this.total - this.pass - this.skipped;\n  },\n  duration: function() {\n    return this._durationFromMs(this.endTime - this.startTime);\n  },\n  _durationFromMs: function(ms) {\n    if (ms)\n    {\n      return (ms / 1000).toFixed(3);\n    } else\n    {\n      return 0;\n    }\n  }\n};\n\nmodule.exports = XUnitReporter;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/reporters/dot_reporter.js":"'use strict';\n\nvar indent = require('../strutils').indent;\nvar printf = require('printf');\n\nfunction DotReporter(silent, out) {\n  this.out = out || process.stdout;\n  this.silent = silent;\n  this.stoppedOnError = null;\n  this.id = 1;\n  this.total = 0;\n  this.pass = 0;\n  this.skipped = 0;\n  this.results = [];\n  this.startTime = new Date();\n  this.endTime = null;\n  this.out.write('\\n');\n  this.out.write('  ');\n}\nDotReporter.prototype = {\n  report: function(prefix, data) {\n    this.results.push({\n      launcher: prefix,\n      result: data\n    });\n    this.display(prefix, data);\n    this.total++;\n    if (data.skipped) {\n      this.skipped++;\n    } else if (data.passed) {\n      this.pass++;\n    }\n  },\n\n  display: function(prefix, result) {\n    if (this.silent) {\n      return;\n    }\n    if (result.passed) {\n      this.out.write('.');\n    } else if (result.skipped) {\n      this.out.write('*');\n    } else {\n      this.out.write('F');\n    }\n  },\n  finish: function() {\n    if (this.silent) {\n      return;\n    }\n    this.endTime = new Date();\n    this.out.write('\\n\\n');\n    this.out.write(this.summaryDisplay());\n    this.out.write('\\n\\n');\n    this.displayErrors();\n  },\n  displayErrors: function() {\n    this.results.forEach(function(data, idx) {\n      var result = data.result;\n      var error = result.error;\n      if (!error) {\n        return;\n      }\n\n      printf(this.out, '%*d) [%s] %s\\n', idx + 1, 3, data.launcher, result.name);\n\n      if (error.message) {\n        printf(this.out, '     %s\\n', error.message);\n      }\n\n      if ('expected' in error && 'actual' in error) {\n        printf(this.out, '\\n' +\n               '     expected: %O\\n' +\n               '       actual: %O\\n', error.expected, error.actual);\n      }\n\n      if (error.stack) {\n        printf(this.out, '\\n%s', indent(error.stack, 5));\n      }\n\n      this.out.write('\\n');\n    }, this);\n  },\n  summaryDisplay: function() {\n    return printf('  %d tests complete (%d ms)', this.total, this.duration());\n  },\n  duration: function() {\n    return Math.round((this.endTime - this.startTime));\n  }\n};\n\nmodule.exports = DotReporter;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/reporters/teamcity_reporter.js":"'use strict';\n\nfunction TeamcityReporter(silent, out) {\n  this.out = out || process.stdout;\n  this.silent = silent;\n  this.stoppedOnError = null;\n  this.id = 1;\n  this.total = 0;\n  this.pass = 0;\n  this.skipped = 0;\n  this.startTime = new Date();\n  this.endTime = null;\n}\nTeamcityReporter.prototype = {\n  report: function(prefix, data) {\n    this.out.write('##teamcity[testStarted name=\\'' + this._namify(prefix, data) + '\\']\\n');\n    this._display(prefix, data);\n    this.total++;\n    if (data.skipped) {\n      this.skipped++;\n    } else if (data.passed) {\n      this.pass++;\n    }\n  },\n  finish: function() {\n    if (this.silent) {\n      return;\n    }\n    this.endTime = new Date();\n    this.out.write('\\n\\n');\n    this.out.write('##teamcity[testSuiteFinished name=\\'testem.suite\\' duration=\\'' + this._duration() + '\\']\\n');\n    this.out.write('\\n\\n');\n  },\n  _display: function(prefix, result) {\n    if (this.silent) {\n      return;\n    }\n    if (result.skipped) {\n      this.out.write('##teamcity[testIgnored name=\\'' + this._namify(prefix, result) + '\\' message=\\'pending\\']\\n');\n    } else if (!result.passed) {\n      var message = (result.error && result.error.message) || '';\n      var stack = (result.error && result.error.stack) || '';\n      this.out.write('##teamcity[testFailed name=\\'' + this._namify(prefix, result) + '\\' message=\\'' + escape(message) + '\\' details=\\'' + escape(stack) + '\\']\\n');\n    }\n    this.out.write('##teamcity[testFinished name=\\'' + this._namify(prefix, result) + '\\']\\n');\n\n  },\n  _namify: function(prefix, result) {\n    var line = (prefix ? (prefix + ' - ') : '') +\n      result.name.trim();\n    return escape(line);\n  },\n  _duration: function() {\n    return Math.round((this.endTime - this.startTime));\n  }\n};\n\n/**\n * Borrowed from https://github.com/travisjeffery/mocha-teamcity-reporter\n * Escape the given `str`.\n */\n\nfunction escape(str) {\n  if (!str) {\n    return '';\n  }\n  return str\n    .toString()\n    .replace(/\\|/g, '||')\n    .replace(/\\n/g, '|n')\n    .replace(/\\r/g, '|r')\n    .replace(/\\[/g, '|[')\n    .replace(/\\]/g, '|]')\n    .replace(/\\u0085/g, '|x')\n    .replace(/\\u2028/g, '|l')\n    .replace(/\\u2029/g, '|p')\n    .replace(/'/g, '|\\'');\n}\n\nmodule.exports = TeamcityReporter;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/reporters/dev/index.js":"/*\n\nappview.js\n==========\n\nThe actual AppView. This encapsulates the entire UI.\n\n*/\n'use strict';\n\nvar StyledString = require('styled_string');\nvar log = require('npmlog');\nvar Backbone = require('backbone');\n\nvar View = require('./view');\nvar tabs = require('./runner_tabs');\nvar constants = require('./constants');\nvar RunnerTab = tabs.RunnerTab;\nvar RunnerTabs = tabs.RunnerTabs;\nvar Screen = require('./screen');\nvar pad = require('../../strutils').pad;\nvar ErrorMessagesPanel = require('./error_messages_panel');\nvar Runner = require('./runner');\n\nmodule.exports = View.extend({\n  defaults: {\n    currentTab: 0,\n    atLeastOneRunner: false\n  },\n  initialize: function(silent, out, config, app, screen) {\n    this.name = 'Testem';\n    this.config = config;\n    this.app = app;\n    this.viewRunners = new Backbone.Collection();\n    this.x = {};\n\n    screen = screen || new Screen();\n\n    this.set('screen', screen);\n\n    this.on('ctrl-c', function() {\n      app.exit();\n    });\n\n    this.initCharm();\n    this.on('inputChar', this.onInputChar.bind(this));\n\n    var runnerTabs = this.runnerTabs = new RunnerTabs([], {\n      appview: this,\n      screen: screen\n    });\n    this.set({\n      runnerTabs: runnerTabs\n    });\n    var self = this;\n    runnerTabs.on('add', function() {\n      runnerTabs.render();\n    });\n\n    this.app.on('runnerAdded', function(runner) {\n      self.runnerAdded(runner);\n    });\n\n    this.app.on('runnerRemoved', function(runner) {\n      self.runnerRemoved(runner);\n    });\n\n    runnerTabs.on('add', function() {\n      runnerTabs.render();\n    });\n    this.on('change:atLeastOneRunner', function(atLeastOne) {\n      if (atLeastOne && self.get('currentTab') < 0) {\n        self.set('currentTab', 0);\n      }\n      self.renderMiddle();\n      self.renderBottom();\n    });\n    this.on('change:lines change:cols', function() {\n      self.render();\n    });\n\n    this.errorMessagesPanel = new ErrorMessagesPanel({\n      appview: this,\n      text: '',\n      screen: screen\n    });\n    this.errorMessagesPanel.on('change:text', function(m, text) {\n      self.set('isPopupVisible', !!text);\n    });\n    this.startMonitorTermSize();\n  },\n\n  runnerAdded: function(runner) {\n    var viewRunner = new Runner(runner);\n    this.viewRunners.push(viewRunner);\n\n    var idx = this.viewRunners.length - 1;\n    this.x[runner.launcherId] = viewRunner;\n\n    log.info('runnerAdded', runner.name(), runner.launcherId);\n\n    var tab = new RunnerTab({\n      runner: viewRunner,\n      index: idx,\n      appview: this,\n      screen: this.get('screen')\n    });\n    this.runnerTabs.push(tab);\n    this.set('atLeastOneRunner', this.viewRunners.length > 0);\n  },\n\n  runnerRemoved: function(runner) {\n    log.info('runnerRemoved');\n\n    this.viewRunners.remove(this.x[runner.launcherId]);\n    this.set('atLeastOneRunner', this.viewRunners.length > 0);\n  },\n\n  _showError: function(titleText, err) {\n    var title = new StyledString(titleText + '\\n ').foreground('red');\n\n    if (err) {\n      var errMsgs = new StyledString('\\n' + err.name)\n                     .foreground('white')\n                     .concat(new StyledString('\\n' + err.message).foreground('red'));\n\n      title += errMsgs;\n    }\n\n    this.setErrorPopupMessage(title);\n\n    if (err) {\n      log.log('warn', titleText);\n    } else {\n      log.log('warn', titleText, {\n        name: err.name,\n        message: err.message\n      });\n    }\n  },\n\n  onInputChar: function(chr, i) {\n    if (chr === 'q') {\n      log.info('Got keyboard Quit command');\n      this.app.exit();\n    } else if (i === 13) { // ENTER\n      log.info('Got keyboard Start Tests command');\n      this.app.triggerRun('Triggered manually by pressing enter');\n    } else if (chr === 'p') {\n      this.app.paused = !this.app.paused;\n      this.renderBottom();\n    }\n  },\n\n  initCharm: function() {\n    var screen = this.get('screen');\n    screen.reset();\n    screen.erase('screen');\n    screen.cursor(false);\n    screen.on('data', this.onScreenData.bind(this));\n    screen.removeAllListeners('^C');\n    screen.on('^C', function() {\n      this.trigger('ctrl-c');\n    }.bind(this));\n  },\n  startMonitorTermSize: function() {\n    var self = this;\n    this.updateScreenDimensions();\n    process.stdout.on('resize', function() {\n      var cols = process.stdout.columns;\n      var lines = process.stdout.rows;\n      if (cols !== self.get('cols') || lines !== self.get('lines')) {\n        self.updateScreenDimensions();\n      }\n    });\n  },\n  updateScreenDimensions: function() {\n    var screen = this.get('screen');\n    var cols = process.stdout.columns;\n    var lines = process.stdout.rows;\n    screen.enableScroll(constants.LogPanelUnusedLines, lines - 1);\n    this.set({\n      cols: cols,\n      lines: lines\n    });\n    this.updateErrorMessagesPanelSize();\n  },\n  updateErrorMessagesPanelSize: function() {\n    this.errorMessagesPanel.set({\n      line: 2,\n      col: 4,\n      width: this.get('cols') - 8,\n      height: this.get('lines') - 4\n    });\n  },\n  render: function() {\n    this.renderTop();\n    if (!this.get('atLeastOneRunner')) {\n      this.renderMiddle();\n    }\n    this.renderBottom();\n  },\n  renderTop: function() {\n    if (this.isPopupVisible()) {\n      return;\n    }\n\n    var screen = this.get('screen');\n    var url = this.config.get('url');\n    var cols = this.get('cols');\n    screen\n      .position(0, 1)\n      .write(pad('TEST\\u0027EM \\u0027SCRIPTS!', cols, ' ', 1))\n      .position(0, 2)\n      .write(pad('Open the URL below in a browser to connect.', cols, ' ', 1))\n      .position(0, 3)\n      .display('underscore')\n      .write(url, cols, ' ', 1)\n      .display('reset')\n      .position(url.length + 1, 3)\n      .write(pad('', cols - url.length, ' ', 1));\n\n  },\n  renderMiddle: function() {\n    if (this.isPopupVisible()) {\n      return;\n    }\n    if (this.viewRunners.length > 0) {\n      return;\n    }\n\n    var screen = this.get('screen');\n    var lines = this.get('lines');\n    var cols = this.get('cols');\n    var textLineIdx = Math.floor(lines / 2 + 2);\n    for (var i = constants.LogPanelUnusedLines; i < lines; i++) {\n      var text = (i === textLineIdx ? 'Waiting for runners...' : '');\n      screen\n        .position(0, i)\n        .write(pad(text, cols, ' ', 2));\n    }\n  },\n  renderBottom: function() {\n    if (this.isPopupVisible()) {\n      return;\n    }\n\n    var screen = this.get('screen');\n    var cols = this.get('cols');\n    var pauseStatus = this.app.paused ? '; p to unpause (PAUSED)' : '; p to pause';\n\n    var msg = (\n      !this.get('atLeastOneRunner') ?\n      'q to quit' :\n      'Press ENTER to run tests; q to quit'\n      );\n    msg = '[' + msg + pauseStatus + ']';\n    screen\n      .position(0, this.get('lines'))\n      .write(pad(msg, cols - 1, ' ', 1));\n  },\n  runners: function() {\n    return this.viewRunners;\n  },\n  currentRunnerTab: function() {\n    var idx = this.get('currentTab');\n    return this.runnerTabs.at(idx);\n  },\n\n  onScreenData: function(buf) {\n    try {\n      var chr = String(buf).charAt(0);\n      var i = chr.charCodeAt(0);\n      var key = (buf[0] === 27 && buf[1] === 91) ? buf[2] : null;\n      var currentRunnerTab = this.currentRunnerTab();\n      var splitPanel = currentRunnerTab && currentRunnerTab.splitPanel;\n\n      //log.info([buf[0], buf[1], buf[2]].join(','))\n      if (key === 67) { // right arrow\n        this.nextTab();\n      } else if (key === 68) { // left arrow\n        this.prevTab();\n      } else if (key === 66) { // down arrow\n        splitPanel.scrollDown();\n      } else if (key === 65) { // up arrow\n        splitPanel.scrollUp();\n      } else if (chr === '\\t') {\n        splitPanel.toggleFocus();\n      } else if (chr === ' ' && splitPanel) {\n        splitPanel.pageDown();\n      } else if (chr === 'b') {\n        splitPanel.pageUp();\n      } else if (chr === 'u') {\n        splitPanel.halfPageUp();\n      } else if (chr === 'd') {\n        splitPanel.halfPageDown();\n      }\n      this.trigger('inputChar', chr, i);\n    } catch (e) {\n      log.error('In onInputChar: ' + e + '\\n' + e.stack);\n    }\n  },\n  nextTab: function() {\n    var currentTab = this.get('currentTab');\n    currentTab++;\n    if (currentTab >= this.runners().length) {\n      currentTab = 0;\n    }\n\n    this.set('currentTab', currentTab);\n  },\n  prevTab: function() {\n    var currentTab = this.get('currentTab');\n    currentTab--;\n    if (currentTab < 0) {\n      currentTab = this.runners().length - 1;\n    }\n\n    this.set('currentTab', currentTab);\n  },\n  setErrorPopupMessage: function(msg) {\n    this.errorMessagesPanel.set('text', msg);\n  },\n  clearErrorPopupMessage: function() {\n    this.errorMessagesPanel.set('text', '');\n    this.render();\n  },\n  isPopupVisible: function() {\n    return !!this.get('isPopupVisible');\n  },\n  setRawMode: function() {\n    if (process.stdin.isTTY) {\n      process.stdin.setRawMode(false);\n    }\n  },\n\n  report: function(browserName, result) {\n    if (isTestemItself(result)) {\n      return this._showError('Testem error', result.error.message);\n    }\n\n    var runner = this.x[result.launcherId];\n    if (!runner) {\n      return;\n    }\n\n    runner.report(result);\n\n    if (result.logs) {\n      result.logs.forEach(function(log) {\n        runner.get('messages').push(log);\n      });\n    }\n  },\n\n  onStart: function(browserName, opts) {\n    if (isTestemItself(opts)) {\n      return this.clearErrorPopupMessage();\n    }\n\n    var runner = this.x[opts.launcherId];\n\n    if (!runner) {\n      return;\n    }\n\n    log.info(browserName, 'onStart');\n\n    runner.onStart();\n  },\n\n  onEnd: function(browserName, opts) {\n    if (isTestemItself(opts)) {\n      return;\n    }\n\n    var runner = this.x[opts.launcherId];\n    if (!runner) {\n      return;\n    }\n\n    log.info(browserName, 'onEnd');\n\n    runner.onEnd();\n  },\n\n  finish: function() {\n    this.cleanup();\n  },\n\n  cleanup: function(cb) {\n    var screen = this.get('screen');\n    screen.display('reset');\n    screen.erase('screen');\n    screen.position(0, 0);\n    screen.enableScroll();\n    screen.cursor(true);\n    this.setRawMode(false);\n    screen.destroy();\n    if (cb) {\n      cb();\n    }\n  }\n});\n\nfunction isTestemItself(opts) {\n  return opts.launcherId === 0;\n}\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/reporters/dev/view.js":"/*\n\nview.js\n==========\n\nBase-class for our view-models.\n*/\n'use strict';\n\nvar Backbone = require('backbone');\n\n// ============== Backbone-based View Models ============================\n\n// View is the base class for our view models. That's right, view-models.\n// All of our views carry state of some sort.\nmodule.exports = Backbone.Model.extend({\n  observe: function(model, thing) {\n    var eventMap;\n    if (typeof thing === 'string' && arguments.length === 3) {\n      eventMap = {};\n      eventMap[thing] = arguments[2];\n    } else {\n      eventMap = thing;\n    }\n    for (var event in eventMap) {\n      model.on(event, eventMap[event]);\n    }\n    if (!this.observers) {\n      this.observers = [];\n    }\n    this.observers.push([model, eventMap]);\n  },\n  destroy: function() {\n    this.removeObservers();\n  },\n  removeObservers: function() {\n    if (!this.observers) {\n      return;\n    }\n    this.observers.forEach(function(observer) {\n      var model = observer[0];\n      var eventMap = observer[1];\n      for (var event in eventMap) {\n        model.off(event, eventMap[event]);\n      }\n    });\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/reporters/dev/runner_tabs.js":"/*\n\nrunner_tabs.js\n==============\n\nImplementation of the tabbed UI. Each tab contains its own log panel.\nWhen the tab is not selected, it hides the associated log panel.\n\n*/\n'use strict';\n\nvar SplitLogPanel = require('./split_log_panel');\nvar View = require('./view');\nvar Backbone = require('backbone');\nvar pad = require('../../strutils').pad;\nvar Chars = require('../../chars');\nvar Screen = require('./screen');\nvar notifier = require('node-notifier');\nvar constants = require('./constants');\nvar TabWidth = constants.TabWidth;\nvar TabStartLine = constants.TabStartLine;\nvar TabHeight = constants.TabHeight;\nvar TabStartCol = constants.TabStartCol;\nvar RunnerTab = exports.RunnerTab = View.extend({\n  defaults: {\n    allPassed: true\n  },\n  col: TabStartCol,\n  line: TabStartLine,\n  height: TabHeight,\n  width: TabWidth,\n  initialize: function() {\n    var runner = this.get('runner');\n    var results = runner.get('results');\n    var index = this.get('index');\n    var appview = this.get('appview');\n    var app = appview.app;\n    var config = app.config;\n    var self = this;\n    var visible = appview.get('currentTab') === index;\n    if (!this.get('screen')) {\n      this.set('screen', new Screen());\n    }\n\n    this.splitPanel = new SplitLogPanel({\n      runner: runner,\n      appview: appview,\n      visible: visible,\n      screen: this.get('screen')\n    });\n\n    this.spinnerIdx = 0;\n\n    function handleCurrentTab() {\n      self.set('selected', appview.get('currentTab') === self.get('index'));\n    }\n\n    this.observe(appview, {\n      'change:currentTab': handleCurrentTab\n    });\n    this.observe(runner, {\n      'change:name': function() {\n        self.renderRunnerName();\n      },\n      'tests-start': function() {\n        self.set('allPassed', true);\n        self.splitPanel.resetScrollPositions();\n        self.startSpinner();\n      },\n      'tests-end': function() {\n        self.stopSpinner();\n        self.renderResults();\n        self.renderRunnerName();\n        if (config.get('growl')) {\n          self.growlResults();\n        }\n      },\n      'change:allPassed': function(model, value) {\n        self.set('allPassed', value);\n      }\n    });\n\n    if (results) {\n      this.observe(results, {\n        change: function() {\n          var results = runner.get('results');\n          if (!results) {\n            self.set('allPassed', true);\n          } else {\n            var passed = results.get('passed');\n            var total = results.get('total');\n            var pending = results.get('pending');\n\n            var allPassed = (passed + pending) === total;\n            var hasTests = total > 0;\n            var failCuzNoTests = !hasTests && config.get('fail_on_zero_tests');\n            var hasError = runner.get('messages').filter(function(m) {\n              return m.get('type') === 'error';\n            }).length > 0;\n            self.set('allPassed',\n              allPassed && !failCuzNoTests && !hasError);\n          }\n        },\n        'change:all': function() {\n          self.renderResults();\n        }\n      });\n    }\n\n    this.observe(appview, 'change:isPopupVisible', function() {\n      self.updateSplitPanelVisibility();\n    });\n\n    this.observe(this, {\n      'change:selected': function() {\n        self.updateSplitPanelVisibility();\n      },\n      'change:index change:selected': function() {\n        self.render();\n      },\n      'change:allPassed': function() {\n        process.nextTick(function() {\n          self.renderRunnerName();\n          self.renderResults();\n        });\n      }\n    });\n    this.render();\n\n    handleCurrentTab();\n  },\n  updateSplitPanelVisibility: function() {\n    var appview = this.get('appview');\n    this.splitPanel.set('visible', this.get('selected') && !appview.isPopupVisible());\n  },\n  color: function() {\n    var appview = this.get('appview');\n    var config = appview.app.config;\n    var runner = this.get('runner');\n    var results = runner.get('results');\n    var equal = true;\n    var hasTests = false;\n    var pending = false;\n    if (results) {\n      var passed = results.get('passed');\n      pending = results.get('pending');\n      var total = results.get('total');\n      equal = (passed + pending) === total;\n      hasTests = total > 0;\n    }\n    var failCuzNoTests = !hasTests && config.get('fail_on_zero_tests');\n    var success = !failCuzNoTests && equal;\n    return success ? (pending ? 'yellow' : 'green') : 'red';\n  },\n  startSpinner: function() {\n    this.stopSpinner();\n    var self = this;\n    function render() {\n      self.renderResults();\n      self.setTimeoutID = setTimeout(render, 150);\n    }\n    render();\n  },\n  stopSpinner: function() {\n    if (this.setTimeoutID) {\n      clearTimeout(this.setTimeoutID);\n    }\n  },\n  isPopupVisible: function isPopupVisible() {\n    var appview = this.get('appview');\n    return appview && appview.isPopupVisible();\n  },\n  render: function() {\n    if (this.isPopupVisible()) {\n      return;\n    }\n    this.renderTab();\n    this.renderRunnerName();\n    this.renderResults();\n  },\n  renderRunnerName: function() {\n    if (this.isPopupVisible()) {\n      return;\n    }\n\n    var screen = this.get('screen');\n    var index = this.get('index');\n    var line = this.line;\n    var width = this.width;\n    var col = this.col + index * width;\n    var runner = this.get('runner');\n    var runnerName = runner.get('name');\n\n    // write line 1\n    screen\n      .foreground(this.color());\n\n    if (this.get('selected')) {\n      screen.display('bright');\n    }\n\n    var runnerDisplayName = pad(runnerName || '', width - 2, ' ', 2);\n    screen\n      .position(col + 1, line + 1)\n      .write(runnerDisplayName)\n      .display('reset');\n  },\n  renderResults: function() {\n    if (this.isPopupVisible()) {\n      return;\n    }\n\n    var screen = this.get('screen');\n    var index = this.get('index');\n    var line = this.line;\n    var width = this.width;\n    var col = this.col + index * width;\n    var runner = this.get('runner');\n    var results = runner.get('results');\n    var resultsDisplay = '';\n    var equal = true;\n\n    if (results) {\n      var total = results.get('total');\n      var passed = results.get('passed');\n      var pending = results.get('pending');\n      resultsDisplay = passed + '/' + total;\n      equal = (passed + pending) === total;\n    }\n\n    if (results && results.get('all')) {\n      resultsDisplay += ' ' + ((this.get('allPassed') && equal) ? Chars.success : Chars.fail);\n    } else if (!results && runner.get('allPassed') !== undefined) {\n      resultsDisplay = runner.get('allPassed') ? Chars.success : Chars.fail;\n    } else {\n      resultsDisplay += ' ' + Chars.spinner[this.spinnerIdx++];\n      if (this.spinnerIdx >= Chars.spinner.length) {\n        this.spinnerIdx = 0;\n      }\n    }\n\n    resultsDisplay = pad(resultsDisplay, width - 4, ' ', 2);\n\n    // write line 1\n    screen\n      .foreground(this.color());\n\n    if (this.get('selected')) {\n      screen.display('bright');\n    }\n\n    screen\n      .position(col + 1, line + 2)\n      .write(resultsDisplay)\n      .display('reset');\n  },\n  growlResults: function() {\n    var runner = this.get('runner');\n    var results = runner.get('results');\n    var name = runner.get('name');\n    var resultsDisplay = results ?\n      (results.get('passed') + '/' + results.get('total')) : 'finished';\n\n    notifier.notify({\n      title: 'Test\\'em',\n      message: name + ' : ' + resultsDisplay\n    });\n  },\n  renderTab: function() {\n    if (this.isPopupVisible()) {\n      return;\n    }\n    if (this.get('selected')) {\n      this.renderSelected();\n    } else {\n      this.renderUnselected();\n    }\n  },\n  renderUnselected: function() {\n    if (this.isPopupVisible()) {\n      return;\n    }\n\n    var screen = this.get('screen');\n    var index = this.get('index');\n    var width = this.width;\n    var height = this.height;\n    var line = this.line;\n    var col = this.col + index * width;\n    var firstCol = index === 0;\n    screen.position(col, line);\n\n    screen.write(new Array(width + 1).join(' '));\n    for (var i = 1; i < height - 1; i++) {\n      if (!firstCol) {\n        screen.position(col, line + i);\n        screen.write(' ');\n      }\n      screen.position(col + width - 1, line + i);\n      screen.write(' ');\n    }\n\n    var bottomLine = new Array(width + 1).join(Chars.horizontal);\n    screen.position(col, line + height - 1);\n    screen.write(bottomLine);\n  },\n  renderSelected: function() {\n    if (this.isPopupVisible()) {\n      return;\n    }\n    var screen = this.get('screen');\n    var index = this.get('index');\n    var width = this.width;\n    var height = this.height;\n    var line = this.line;\n    var col = this.col + index * width;\n    var firstCol = index === 0;\n    screen.position(col, line);\n\n    screen.write((firstCol ? Chars.horizontal : Chars.topLeft) +\n      new Array(width - 1).join(Chars.horizontal) +\n        Chars.topRight);\n    for (var i = 1; i < height - 1; i++) {\n      if (!firstCol) {\n        screen.position(col, line + i);\n        screen.write(Chars.vertical);\n      }\n      screen.position(col + width - 1, line + i);\n      screen.write(Chars.vertical);\n    }\n\n    var bottomLine = (firstCol ? ' ' : Chars.bottomRight) +\n      new Array(width - 1).join(' ') + Chars.bottomLeft;\n    screen.position(col, line + height - 1);\n    screen.write(bottomLine);\n  },\n  destroy: function() {\n    this.stopSpinner();\n    this.splitPanel.destroy();\n    View.prototype.destroy.call(this);\n  }\n});\n\n// View container for all the tabs. It'll handle clean up of removed tabs and draw\n// the edge for where there are no tabs.\nexports.RunnerTabs = Backbone.Collection.extend({\n  model: RunnerTab,\n  initialize: function(arr, attrs) {\n    this.appview = attrs.appview;\n    var self = this;\n    this.screen = attrs.screen || new Screen();\n    this.on('remove', function(removed) {\n      var currentTab = self.appview.get('currentTab');\n      if (currentTab >= self.length) {\n        currentTab--;\n        self.appview.set('currentTab', currentTab, {silent: true});\n      }\n      self.forEach(function(runner, idx) {\n        runner.set({\n          index: idx,\n          selected: idx === currentTab\n        });\n      });\n      self.eraseLast();\n      removed.destroy();\n      if (self.length === 0) {\n        self.blankOutBackground();\n      }\n    });\n    this.appview.on('change:isPopupVisible change:lines change:cols', function() {\n      self.reRenderAll();\n    });\n  },\n  reRenderAll: function() {\n    this.blankOutBackground();\n    this.render();\n  },\n  blankOutBackground: function() {\n    if (this.isPopupVisible()) {\n      return;\n    }\n    var screen = this.screen;\n    var cols = this.appview.get('cols');\n    for (var i = 0; i < TabHeight; i++) {\n      screen\n        .position(0, TabStartLine + i)\n        .write(pad('', cols, ' ', 1));\n    }\n  },\n  render: function() {\n    if (this.isPopupVisible()) {\n      return;\n    }\n    this.invoke('render');\n    if (this.length > 0) {\n      this.renderLine();\n    }\n  },\n  renderLine: function() {\n    if (this.isPopupVisible()) {\n      return;\n    }\n    var screen = this.screen;\n    var startCol = this.length * TabWidth;\n    var lineLength = this.appview.get('cols') - startCol + 1;\n    if (lineLength > 0) {\n      screen\n        .position(startCol + 1, TabStartLine + TabHeight - 1)\n        .write(new Array(lineLength).join(Chars.horizontal));\n    }\n  },\n  eraseLast: function() {\n    if (this.isPopupVisible()) {\n      return;\n    }\n    var screen = this.screen;\n    var index = this.length;\n    var width = TabWidth;\n    var height = TabHeight;\n    var line = TabStartLine;\n    var col = TabStartCol + index * width;\n\n    for (var i = 0; i < height - 1; i++) {\n      screen\n        .position(col, line + i)\n        .write(new Array(width + 1).join(' '));\n    }\n\n    var bottomLine = new Array(width + 1).join(Chars.horizontal);\n    screen.position(col, line + height - 1);\n    screen.write(bottomLine);\n  },\n  isPopupVisible: function isPopupVisible() {\n    var appview = this.appview;\n    return appview && appview.isPopupVisible();\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/reporters/dev/split_log_panel.js":"'use strict';\n\nvar View = require('./view');\nvar ScrollableTextPanel = require('./scrollable_text_panel');\nvar tabs = require('./constants');\nvar styledString = require('styled_string');\nvar Chars = require('../../chars');\nvar indent = require('../../strutils').indent;\nvar Screen = require('./screen');\n\nfunction failureDisplay(item) {\n  var extra = [];\n  var stacktrace = item.stack;\n  if (stacktrace) {\n    var stacklines = stacktrace.split('\\n');\n    if (stacklines[0] === item.message) {\n      stacktrace = stacklines.slice(1).map(function(line) {\n        return line.trim();\n      }).join('\\n');\n    }\n    extra.push(stacktrace);\n  } else {\n    if (item.file) {\n      extra.push(item.file);\n    }\n    if (item.line) {\n      extra.push(' ' + item.line);\n    }\n  }\n\n  if (item.expected) {\n    extra.push(' expected ' + item.expected);\n  }\n\n  if (item.actual) {\n    extra.push(' actual ' + item.actual);\n  }\n\n  if (item.at) {\n    extra.push(' at ' + item.at);\n  }\n\n  return Chars.cross + ' ' + (item.message || 'failed') +\n    (extra ? '\\n' + indent(extra.join('\\n')) : '');\n}\n\nfunction failedTestDisplay(test) {\n  var failedItems = (test.get('items') || []).filter(function(item) {\n    return !item.passed;\n  });\n  return test.get('name') + '\\n' +\n    indent(failedItems.map(failureDisplay).join('\\n'));\n}\n\nmodule.exports = View.extend({\n  defaults: {\n    visible: false,\n    focus: 'top'\n  },\n  initialize: function() {\n    if (!this.get('screen')) {\n      this.set('screen', new Screen());\n    }\n    var runner = this.get('runner');\n    var results = runner.get('results');\n    var messages = runner.get('messages');\n    var appview = this.get('appview');\n    var visible = this.get('visible');\n    var self = this;\n    var screen = this.get('screen');\n    var topPanel = this.topPanel = new ScrollableTextPanel({\n      line: tabs.TabStartLine + tabs.TabHeight - 1,\n      col: 0,\n      visible: visible,\n      screen: screen\n    });\n    var bottomPanel = this.bottomPanel = new ScrollableTextPanel({\n      col: 0,\n      visible: visible,\n      screen: screen\n    });\n    this.observe(appview, 'change:cols change:lines', function() {\n      self.syncDimensions();\n      self.render();\n    });\n    if (results) {\n      this.observe(results, 'change', function() {\n        self.syncDimensions();\n        self.syncResultsDisplay();\n      });\n    }\n    this.observe(messages, 'reset add remove', function() {\n      self.syncDimensions();\n      self.syncMessages();\n    });\n    this.observe(this, 'change:visible', function() {\n      var visible = self.get('visible');\n      topPanel.set('visible', visible, {silent: true});\n      bottomPanel.set('visible', visible, {silent: true});\n      self.syncDimensions({silent: true});\n      self.render();\n    });\n    this.syncDimensions({silent: true});\n    this.syncResultsDisplay({silent: true});\n    this.syncMessages({silent: true});\n    this.render();\n  },\n  toggleFocus: function() {\n    var focus = this.get('focus');\n    this.set('focus', focus === 'top' ? 'bottom' : 'top');\n  },\n  resetScrollPositions: function() {\n    this.topPanel.set('scrollOffset', 0);\n    this.bottomPanel.set('scrollOffset', 0);\n  },\n  targetPanel: function() {\n    var runner = this.get('runner');\n    var bottomPanel = this.bottomPanel;\n    var topPanel = this.topPanel;\n    if (runner.hasMessages() && runner.hasResults()) {\n      return (this.get('focus') === 'top') ? topPanel : bottomPanel;\n    } else if (runner.hasMessages()) {\n      return bottomPanel;\n    } else if (runner.hasResults()) {\n      return topPanel;\n    } else {\n      return topPanel;\n    }\n  },\n  scrollUp: function() {\n    this.targetPanel().scrollUp();\n  },\n  scrollDown: function() {\n    this.targetPanel().scrollDown();\n  },\n  pageUp: function() {\n    this.targetPanel().pageUp();\n  },\n  pageDown: function() {\n    this.targetPanel().pageDown();\n  },\n  halfPageUp: function() {\n    this.targetPanel().halfPageUp();\n  },\n  halfPageDown: function() {\n    this.targetPanel().halfPageDown();\n  },\n  syncMessages: function(options) {\n    this.bottomPanel.set('text', this.getMessagesText(), options);\n  },\n  syncResultsDisplay: function(options) {\n    this.topPanel.set('text', this.getResultsDisplayText(), options);\n  },\n  syncDimensions: function(options) {\n    var appview = this.get('appview');\n    var termCols = appview.get('cols');\n    var termLines = appview.get('lines');\n    var runner = this.get('runner');\n    if (runner.hasMessages() && runner.hasResults()) {\n      var midLine = Math.floor((termLines - tabs.LogPanelUnusedLines) / 2);\n\n      this.topPanel.set({\n        height: midLine,\n        width: termCols\n      }, options);\n      var line = midLine + tabs.TabStartLine + tabs.TabHeight - 1;\n      var bottomPanelAttrs = {\n        line: line,\n        height: termLines - line - 1,\n        width: termCols\n      };\n      this.bottomPanel.set(bottomPanelAttrs, options);\n    } else if (runner.hasMessages()) { // only has messages\n      this.topPanel.set({\n        height: 0,\n        width: termCols\n      }, options);\n      var height = termLines - tabs.LogPanelUnusedLines;\n      this.bottomPanel.set({\n        line: tabs.TabStartLine + tabs.TabHeight - 1,\n        height: height,\n        width: termCols\n      }, options);\n    } else { // only has results\n\n      // Hide the bottom panel if there are no messages\n      // to be displayed\n      var topPanelHeight = termLines - tabs.LogPanelUnusedLines;\n      this.topPanel.set({\n        height: topPanelHeight,\n        width: termCols\n      }, options);\n      this.bottomPanel.set({\n        line: tabs.TabStartLine + tabs.TabHeight + topPanelHeight,\n        height: 0,\n        width: termCols\n      }, options);\n    }\n  },\n  render: function() {\n    this.topPanel.render();\n    this.bottomPanel.render();\n  },\n  getResultsDisplayText: function() {\n    var runner = this.get('runner');\n    var results = runner.get('results');\n    var topLevelError = results ? results.get('topLevelError') : null;\n    var tests = null;\n    var out = '';\n    var pendingOut = '';\n\n    if (topLevelError) {\n      out += 'Top Level:\\n' + indent(topLevelError) + '\\n\\n';\n    }\n\n    if (results && (tests = results.get('tests'))) {\n      var total = results.get('total');\n      var pending = results.get('pending');\n      var allDone = results.get('all');\n      if (!total) {\n        out = allDone ? 'No tests were run :(' : 'Please be patient :)';\n      } else {\n        var failedTests = tests.filter(function(test) {\n          return test.get('failed') > 0;\n        });\n        if (failedTests.length > 0) {\n          out += failedTests.map(failedTestDisplay).join('\\n');\n        } else { // All passed\n          if (allDone) {\n            var pendingTests = tests.filter(function(test) {\n              return test.get('pending') > 0;\n            });\n            out += Chars.success + ' ' + total + ' tests complete';\n            if (pending > 0) {\n              out += ' (' + pending + ' pending)';\n            }\n            out += '.';\n            if (pending) {\n              pendingOut += '\\n\\n';\n              pendingOut += pendingTests.map(function(test) {\n                return '[PENDING] ' + test.get('name');\n              }).join('\\n');\n            }\n          } else {\n            out += 'Looking good...';\n          }\n        }\n      }\n    }\n\n    return styledString(out, {foreground: 'cyan'})\n      .append(styledString(pendingOut, {foreground: 'yellow'}));\n  },\n  getMessagesText: function() {\n    var messages = this.get('runner').get('messages');\n    var retval = styledString('');\n\n    messages.forEach(function(message) {\n      var type = message.get('type');\n      var text = message.get('text');\n\n      var color = 'yellow';\n\n      switch (type) {\n        case 'warn':\n          color = 'cyan';\n          break;\n        case 'info':\n          color = 'green';\n          break;\n        case 'error':\n          color = 'red';\n          break;\n      }\n\n      retval = retval.concat(styledString(text, {foreground: color}));\n    });\n    return retval;\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/reporters/dev/scrollable_text_panel.js":"'use strict';\n\nvar View = require('./view');\nvar splitLines = require('../../strutils').splitLines;\nvar Screen = require('./screen');\n\n// This is a generic scrollable text viewer widget. Should be refactored\n// out to another file or npm module at some point.\nmodule.exports = View.extend({\n  defaults: {\n    visible: true,\n    text: '',\n    textLines: [],\n    scrollOffset: 0\n  },\n\n  // expect the attributes to have\n  // -----------------------------\n  //\n  // * line and col (top left coordinates)\n  // * height and width\n  initialize: function() {\n    var self = this;\n    if (!this.get('screen')) {\n      this.set('screen', new Screen());\n    }\n    this.updateTextLines();\n    this.observe(this, 'change:text change:width', function() {\n      self.updateTextLines();\n    });\n    this.observe(this, 'change:visible change:textLines change:height', function() {\n      self.render();\n    });\n    this.render();\n  },\n  updateTextLines: function() {\n    var text = this.get('text');\n    var lines = splitLines(text, this.get('width'));\n    this.set('textLines', lines);\n  },\n  scrollUp: function() {\n    var scrollOffset = this.get('scrollOffset');\n    if (scrollOffset > 0) {\n      scrollOffset--;\n      this.set('scrollOffset', scrollOffset, {silent: true});\n      this.render();\n    }\n  },\n  scrollDown: function() {\n    var height = this.get('height');\n    var scrollOffset = this.get('scrollOffset');\n    var textLines = this.get('textLines');\n    if (textLines.length > height + scrollOffset) {\n      scrollOffset++;\n      this.set('scrollOffset', scrollOffset, {silent: true});\n      this.render();\n    }\n  },\n  pageUp: function() {\n    var height = this.get('height');\n    var scrollOffset = this.get('scrollOffset');\n    this.scrollTo(Math.max(0, scrollOffset - height));\n  },\n  pageDown: function() {\n    var height = this.get('height');\n    var scrollOffset = this.get('scrollOffset');\n    var textLines = this.get('textLines');\n    this.scrollTo(Math.min(scrollOffset + height, textLines.length - height));\n  },\n  halfPageUp: function() {\n    var height = this.get('height');\n    var scrollOffset = this.get('scrollOffset');\n    this.scrollTo(Math.max(0, scrollOffset - Math.ceil(height / 2)));\n  },\n  halfPageDown: function() {\n    var height = this.get('height');\n    var scrollOffset = this.get('scrollOffset');\n    var textLines = this.get('textLines');\n    this.scrollTo(Math.min(scrollOffset + Math.ceil(height / 2), textLines.length - height));\n  },\n  scrollTo: function(newOffset) {\n    var scrollOffset = this.get('scrollOffset');\n    if (scrollOffset !== newOffset) {\n      this.set('scrollOffset', newOffset, {slient: true});\n      this.render();\n    }\n  },\n  render: function(firstOrLast) {\n    if (!this.get('visible')) {\n      return;\n    }\n\n    var screen = this.get('screen');\n    var startLine = this.get('line');\n    var col = this.get('col');\n    var width = this.get('width');\n    var height = this.get('height');\n    var textLines = this.get('textLines');\n    var scrollOffset = this.get('scrollOffset');\n\n    function renderLine(i) {\n      var idx = i + scrollOffset;\n      var textLine = textLines[idx] || '';\n      var output = textLine.toString();\n      screen\n        .position(col, startLine + i + 1)\n        .write(output);\n      if (textLine.length < width) {\n        screen.erase('end');\n      }\n    }\n\n    if (!firstOrLast) {\n      for (var i = 0; i < height; i++) {\n        renderLine(i);\n      }\n    } else if (firstOrLast === 'first') {\n      renderLine(0);\n    } else if (firstOrLast === 'last') {\n      renderLine(height - 1);\n    }\n\n    screen.display('reset');\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/reporters/dev/screen.js":"'use strict';\n\nvar charm;\n\nfunction initCharm() {\n\n  if (charm) {\n    return charm;\n  }\n\n  // A wrapper around charm (gives the same API) that automatically parks the cursor\n  // to the bottom right corner when not in use\n  charm = (function(charm) {\n    var timeoutID;\n    function parkCursor() {\n      charm.position(process.stdout.columns, process.stdout.rows);\n    }\n    function wrapFunc(func) {\n      return function() {\n        if (timeoutID) {\n          clearTimeout(timeoutID);\n        }\n        var retval = func.apply(charm, arguments);\n        timeoutID = setTimeout(parkCursor, 150);\n        return retval;\n      };\n    }\n    var cursorParker = {};\n    for (var prop in charm) {\n      var value = charm[prop];\n      if (typeof value === 'function') {\n        cursorParker[prop] = wrapFunc(value);\n      }\n    }\n    return cursorParker;\n  })(require('charm')(process));\n\n  // allow charm.write() to take any object: just convert the passed in object to a string\n  charm.write = (function(charm, write) {\n    return function(obj) {\n      if (!(obj instanceof Buffer) && typeof obj !== 'string') {\n        obj = String(obj);\n      }\n      return write.call(charm, obj);\n    };\n  })(charm, charm.write);\n  return charm;\n}\n\nrequire('./patchcharm.js');\nmodule.exports = initCharm;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/reporters/dev/patchcharm.js":"/*\n\npatchcharm.js\n=============\n\nA patch to charm to add text scrolling capability\nand also a fix to `erase()`.\n\n*/\n'use strict';\n\nvar charm = require('charm');\nvar Charm = charm.Charm;\n\nvar encode = function(xs) {\n  function bytes(s) {\n    if (typeof s === 'string') {\n      return s.split('').map(ord);\n    } else if (Array.isArray(s)) {\n      return s.reduce(function(acc, c) {\n        return acc.concat(bytes(c));\n      }, []);\n    }\n  }\n\n  return new Buffer([0x1b].concat(bytes(xs)));\n};\n\nfunction ord(c) {\n  return c.charCodeAt(0);\n}\n\nCharm.prototype.erase = function(s) {\n  if (s === 'end' || s === '$') {\n    this.write(encode('[K'));\n  } else if (s === 'start' || s === '^') {\n    this.write(encode('[1K'));\n  } else if (s === 'line') {\n    this.write(encode('[2K'));\n  } else if (s === 'down') {\n    this.write(encode('[J'));\n  } else if (s === 'up') {\n    this.write(encode('[1J'));\n  } else if (s === 'screen') {\n    this.write(encode('[2J'));\n  } else {\n    this.emit('error', new Error('Unknown erase type: ' + s));\n  }\n  return this;\n};\n\nCharm.prototype.enableScroll = function() {\n  if (arguments.length === 0 || arguments[0] === 'screen') {\n    this.write(encode('[r'));\n  } else {\n    var start = arguments[0];\n    var end = arguments[1];\n    this.write(encode('[' + start + ';' + end + 'r'));\n  }\n  return this;\n};\n\nCharm.prototype.scrollUp = function() {\n  this.write(encode('M'));\n};\n\nCharm.prototype.scrollDown = function() {\n  this.write(encode('D'));\n};\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/reporters/dev/constants.js":"'use strict';\n\nexports.TabWidth = 15;     // column width of each tab\nexports.TabStartLine = 4;  // row from the top to start drawing tabs\nexports.TabHeight = 4;     // the height in rows of each tab\nexports.TabStartCol = 1;   // col from the left to start drawing tabs\nexports.LogPanelUnusedLines = 8;  // number of rows in the UI does not belong to the log panel\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/reporters/dev/error_messages_panel.js":"'use strict';\n\nvar ScrollableTextPanel = require('./scrollable_text_panel');\nvar Chars = require('../../chars');\n\nmodule.exports = ScrollableTextPanel.extend({\n  initialize: function(attrs) {\n    this.updateVisibility();\n    this.on('change:text', function(self) {\n      self.updateVisibility();\n    });\n    ScrollableTextPanel.prototype.initialize.call(this, attrs);\n  },\n  updateVisibility: function() {\n    var text = this.get('text');\n    this.set('visible', !!text);\n  },\n  render: function() {\n    var visible = this.get('visible');\n    if (!visible) {\n      return;\n    }\n\n    ScrollableTextPanel.prototype.render.call(this);\n\n    // draw a box\n    var line = this.get('line');\n    var col = this.get('col') - 1;\n    var width = this.get('width') + 1;\n    var height = this.get('height') + 1;\n\n    // TODO Figure this out\n    if (isNaN(width)) {\n      return;\n    }\n\n    var screen = this.get('screen');\n    screen.foreground('red');\n    screen.position(col, line);\n    screen.write(Chars.topLeft + new Array(width).join(Chars.horizontal) + Chars.topRight);\n\n    for (var l = line + 1; l < line + height; l++) {\n      screen.position(col, l);\n      screen.write(Chars.vertical);\n      screen.position(col + width, l);\n      screen.write(Chars.vertical);\n    }\n\n    screen.position(col, line + height);\n    screen.write(Chars.bottomLeft + new Array(width).join(Chars.horizontal) + Chars.bottomRight);\n    screen.display('reset');\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/reporters/dev/runner.js":"'use strict';\n\nvar Backbone = require('backbone');\n\nvar TestResults = require('./test_results');\n\nmodule.exports = Backbone.Model.extend({\n  initialize: function(runner) {\n    this.set({\n      messages: new Backbone.Collection(),\n      results: new TestResults(),\n      runner: runner,\n      name: runner.name()\n    });\n  },\n\n  report: function(result) {\n    this.get('results').addResult(result);\n  },\n\n  onStart: function() {\n    this.get('results').reset();\n    this.get('messages').reset();\n    this.set('allPassed', undefined);\n    this.trigger('tests-start');\n  },\n\n  onEnd: function() {\n    this.get('results').set('all', true);\n    this.trigger('tests-end');\n  },\n\n  hasResults: function() {\n    return this.get('results').get('total') > 0;\n  },\n  hasMessages: function() {\n    return this.get('messages').length > 0;\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/reporters/dev/test_results.js":"'use strict';\n\nvar Backbone = require('backbone');\n\nvar TestResults = Backbone.Model.extend({\n  initialize: function() {\n    this.reset();\n  },\n  reset: function() {\n    this.set({\n      topLevelError: null,\n      failed: 0,\n      passed: 0,\n      pending: 0,\n      total: 0,\n      tests: new Backbone.Collection(),\n      all: false\n    });\n  },\n  addResult: function(result) {\n    var total = this.get('total');\n    var pending = this.get('pending');\n    var passed = this.get('passed');\n    var failed = this.get('failed');\n    total++;\n    if (result.pending) {\n      pending++;\n    } else if (result.failed === 0) {\n      passed++;\n    } else {\n      failed++;\n    }\n    this.get('tests').push(result);\n    this.set({\n      total: total,\n      pending: pending,\n      passed: passed,\n      failed: failed,\n      items: result.items\n    });\n  }\n});\n\nmodule.exports = TestResults;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/utils/report-file.js":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar mkdirp = require('mkdirp');\nvar PassThrough = require('stream').PassThrough;\nvar Bluebird = require('bluebird');\n\nfunction ReportFile(reportFile) {\n  this.file = reportFile;\n\n  this.outputStream = new PassThrough();\n\n  mkdirp.sync(path.dirname(path.resolve(reportFile)));\n\n  this.outputStream = fs.createWriteStream(reportFile, { flags: 'w+' });\n\n  var alreadyEnded = false;\n  function finish(data) {\n    if (!alreadyEnded) {\n      alreadyEnded = true;\n      this.outputStream.end(data);\n    }\n  }\n\n  this.outputStream.on('end', finish);\n  this.outputStream.on('error', finish);\n\n  this.closePromise = new Bluebird.Promise(function(resolve, reject) {\n    this.outputStream.on('finish', resolve);\n    this.outputStream.on('error', reject);\n  }.bind(this));\n}\n\nReportFile.prototype.close = function() {\n  this.outputStream.end();\n\n  return this.closePromise;\n};\n\nmodule.exports = ReportFile;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/lib/utils/signal-listeners.js":"'use strict';\n\nvar Bluebird = require('bluebird');\nvar EventEmitter = require('events').EventEmitter;\n\nfunction SignalListeners() {}\n\nSignalListeners.with = function() {\n  var signalListeners = new SignalListeners();\n\n  return signalListeners.add().disposer(function() {\n    return signalListeners.remove();\n  });\n};\n\nSignalListeners.prototype.__proto__ = EventEmitter.prototype;\n\nSignalListeners.prototype.add = Bluebird.method(function() {\n  this._boundSigInterrupt = function() {\n    this.emit('signal', new Error('Received SIGINT signal'));\n  }.bind(this);\n  process.on('SIGINT', this._boundSigInterrupt);\n\n  this._boundSigTerminate = function() {\n    this.emit('signal', new Error('Received SIGTERM signal'));\n  }.bind(this);\n  process.on('SIGTERM', this._boundSigTerminate);\n\n  return this;\n});\n\nSignalListeners.prototype.remove = Bluebird.method(function() {\n  if (this._boundSigInterrupt) {\n    process.removeListener('SIGINT', this._boundSigInterrupt);\n  }\n  if (this._boundSigTerminate) {\n    process.removeListener('SIGTERM', this._boundSigTerminate);\n  }\n});\n\nmodule.exports = SignalListeners;\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/public/.eslintrc.js":"'use strict';\n\nmodule.exports = {\n  env: {\n    browser: true,\n    node: false\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-testem/node_modules/testem/testem.js":"#!/usr/bin/env node\n'use strict';\n\nvar program = require('commander');\nvar progOptions = program;\nvar Config = require('./lib/config');\nvar Api = require('./lib/api');\nvar appMode = 'dev';\n\nprogram\n  .version(require(__dirname + '/package').version)\n  .usage('[options]')\n  .option('-f, --file [file]', 'config file - defaults to testem.json or testem.yml')\n  .option('-p, --port [num]', 'server port - defaults to 7357', Number)\n  .option('--host [hostname]', 'host name - defaults to localhost', String)\n  .option('-l, --launch [list]', 'list of launchers to launch(comma separated)')\n  .option('-s, --skip [list]', 'list of launchers to skip(comma separated)')\n  .option('-d, --debug [file]', 'output debug to debug log - defaults to testem.log')\n  .option('-t, --test_page [page]', 'the html page to drive the tests')\n  .option('-g, --growl', 'turn on growl / native notifications');\n\nprogram\n  .command('launchers')\n  .description('Print the list of available launchers (browsers & process launchers)')\n  .action(act(function(env) {\n    env.__proto__ = program;\n    progOptions = env;\n    appMode = 'launchers';\n  }));\n\nprogram\n  .command('ci')\n  .description('Continuous integration mode')\n  .option('-T, --timeout [sec]', 'timeout a browser after [sec] seconds', null)\n  .option('-P, --parallel [num]', 'number of browsers to run in parallel, defaults to 1', Number)\n  .option('-b, --bail_on_uncaught_error', 'Bail on any uncaught errors')\n  .option('-R, --reporter [reporter]', 'Test reporter to use [tap|dot|xunit|teamcity]')\n  .action(act(function(env) {\n    env.__proto__ = program;\n    progOptions = env;\n    appMode = 'ci';\n  }));\n\nprogram\n  .command('server')\n  .description('Run just the server')\n  .action(act(function(env) {\n    env.__proto__ = program;\n    progOptions = env;\n    appMode = 'server';\n  }));\n\nprogram.on('--help', function() {\n  console.log('  Keyboard Controls (in dev mode):\\n');\n  console.log('    ENTER                  run the tests');\n  console.log('    q                      quit');\n  console.log('    LEFT ARROW             move to the next browser tab on the left');\n  console.log('    RIGHT ARROW            move to the next browser tab on the right');\n  console.log('    TAB                    switch between top and bottom panel (split mode only)');\n  console.log('    UP ARROW               scroll up in the target text panel');\n  console.log('    DOWN ARROW             scroll down in the target text panel');\n  console.log('    SPACE                  page down in the target text panel');\n  console.log('    b                      page up in the target text panel');\n  console.log('    d                      half a page down in the target text panel');\n  console.log('    u                      half a page up in the target text panel');\n  console.log();\n});\n\nmain();\nfunction main() {\n  program.parse(process.argv);\n\n  var config = new Config(appMode, progOptions);\n  if (appMode === 'launchers') {\n    config.read(function() {\n      config.printLauncherInfo();\n    });\n  } else {\n    var api = new Api();\n    if (appMode === 'ci') {\n      api.startCI(progOptions);\n    } else if (appMode === 'dev') {\n      api.startDev(progOptions);\n    } else if (appMode === 'server') {\n      api.startServer(progOptions);\n    }\n  }\n}\n\n// this is to workaround the weird behavior in command where\n// if you provide additional command line arguments that aren't\n// options, it goes in as a string as the 1st arguments of the\n// \"action\" callback, we don't want this\nfunction act(fun) {\n  return function() {\n    var options = arguments[arguments.length - 1];\n    fun(options);\n  };\n}\n"}